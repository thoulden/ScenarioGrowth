<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Growth Model</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .file-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .params-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .param-group {
            display: flex;
            flex-direction: column;
        }
        .param-group label {
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }
        .param-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .param-group small {
            color: #888;
            margin-top: 3px;
        }
        .param-section-title {
            color: #555;
            font-size: 14px;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .param-section-title:first-of-type {
            margin-top: 0;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .template-btn {
            background: #28a745;
            margin-top: 0;
        }
        .template-btn:hover {
            background: #1e7e34;
        }
        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            color: #555;
            text-align: center;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .status.error {
            background: #fee;
            color: #c00;
        }
        .status.success {
            background: #efe;
            color: #060;
        }
        .status.info {
            background: #eef;
            color: #006;
        }
        .hidden {
            display: none;
        }
        .data-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .data-section h2 {
            margin-top: 0;
            color: #555;
        }
        #scenarioTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        #scenarioTable th,
        #scenarioTable td {
            padding: 4px 2px;
            text-align: right;
            border-bottom: 1px solid #eee;
        }
        #scenarioTable th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        #scenarioTable td:first-child,
        #scenarioTable th:first-child {
            text-align: left;
            font-weight: 500;
            white-space: nowrap;
            padding-right: 10px;
        }
        #scenarioTable input {
            width: 72px;
            border: 1px solid transparent;
            background: transparent;
            text-align: right;
            font-size: 12px;
            font-family: inherit;
            padding: 3px 4px;
            border-radius: 3px;
        }
        #scenarioTable input:hover {
            border-color: #ccc;
            background: #fafafa;
        }
        #scenarioTable input:focus {
            border-color: #007bff;
            background: #fff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.15);
        }
        #scenarioTable input.invalid {
            border-color: #dc3545;
            background: #fff5f5;
        }
        #scenarioTable .derived-cell {
            display: inline-block;
            width: 72px;
            text-align: right;
            font-size: 12px;
            padding: 3px 4px;
            color: #555;
        }
        .upload-label:hover {
            background: #5a6268 !important;
        }
        .results-table {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        th, td {
            padding: 8px;
            text-align: right;
            border-bottom: 1px solid #eee;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        td:first-child, th:first-child {
            text-align: left;
        }
    </style>
</head>
<body>
    <h1>Scenario Growth Model</h1>

    <div class="data-section">
        <h2>Scenario Data</h2>
        <p>Edit the values below directly, or upload a CSV file to load a different scenario.</p>
        <div style="margin-bottom: 15px; padding: 10px; background: #f0f7ff; border-radius: 4px; border: 1px solid #cce5ff;">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="useUSMode" checked style="margin-right: 10px; width: 18px; height: 18px;">
                <span style="font-weight: 600; color: #004085;">US Economy</span>
                <small style="margin-left: 10px; color: #666;">(Apply US share of global compute and robots; uncheck for Global)</small>
            </label>
        </div>
        <div id="scenarioTableWrapper" style="overflow-x: auto; margin-bottom: 15px;">
            <!-- Table built by JS on page load -->
        </div>
        <div class="file-input-wrapper">
            <button id="resetDefaults" class="template-btn" title="Reset table to template defaults">Reset Defaults</button>
            <button id="downloadTemplate" class="template-btn">Download CSV</button>
            <label class="upload-label" style="display:inline-block; background:#6c757d; color:white; padding:8px 16px; border-radius:4px; cursor:pointer; font-size:14px;">
                Upload CSV
                <input type="file" id="fileInput" accept=".csv" style="display:none;">
            </label>
        </div>
        <div id="status" class="status hidden"></div>
    </div>

    <div class="params-section">
        <h2>Model Parameters</h2>

        <details style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
            <summary style="cursor: pointer; font-weight: 600; color: #333;">Key Starting Values &amp; Assumptions (click to expand)</summary>
            <div style="margin-top: 10px; font-size: 13px; line-height: 1.6;">
                <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                    <thead>
                        <tr style="border-bottom: 2px solid #ccc; text-align: left;">
                            <th style="padding: 4px 8px;">Category</th>
                            <th style="padding: 4px 8px;">Parameter</th>
                            <th style="padding: 4px 8px;">US</th>
                            <th style="padding: 4px 8px;">Global</th>
                            <th style="padding: 4px 8px;">Confidence</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;" colspan="5"><strong>Base-Year Macro (2025)</strong></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">GDP / Output</td>
                            <td style="padding: 4px 8px;">Y₀</td>
                            <td style="padding: 4px 8px;">$30.6T</td>
                            <td style="padding: 4px 8px;">$117T</td>
                            <td style="padding: 4px 8px; color: green;">High — IMF WEO Oct 2025 (NGDPD)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Productive Capital</td>
                            <td style="padding: 4px 8px;">K₀</td>
                            <td style="padding: 4px 8px;">$91.8T</td>
                            <td style="padding: 4px 8px;">$410T</td>
                            <td style="padding: 4px 8px; color: #b8860b;">US: High (BEA Fixed Assets Table 5.10) / World: Low (PWT 11.0 cn series)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">K/Y ratio</td>
                            <td style="padding: 4px 8px;">K₀/Y₀</td>
                            <td style="padding: 4px 8px;">3.0</td>
                            <td style="padding: 4px 8px;">~3.5</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Medium — derived from K₀/Y₀; NET K/Y (gross ~4.0-4.5); PWT PPP gives 3.24 US, 4.71 world</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Labor share</td>
                            <td style="padding: 4px 8px;">1−α−s_L</td>
                            <td style="padding: 4px 8px;">58.3%</td>
                            <td style="padding: 4px 8px;">52.3%</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Medium — US: FRED MPU4910141 (BLS MFP, 2024); World: ILO WESO Sep 2024 (2022)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Labor Force</td>
                            <td style="padding: 4px 8px;">L₀</td>
                            <td style="padding: 4px 8px;">168.6M</td>
                            <td style="padding: 4px 8px;">3.5B</td>
                            <td style="padding: 4px 8px; color: green;">High — BLS / ILO</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Working Age Pop</td>
                            <td style="padding: 4px 8px;">WAP₀</td>
                            <td style="padding: 4px 8px;">270.7M</td>
                            <td style="padding: 4px 8px;">5.1B</td>
                            <td style="padding: 4px 8px; color: green;">High — Census / UN Population Division</td>
                        </tr>

                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;" colspan="5"><strong>Production Function</strong></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Capital share</td>
                            <td style="padding: 4px 8px;">α = 0.30</td>
                            <td style="padding: 4px 8px;">30%</td>
                            <td style="padding: 4px 8px;">32.9%</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Low-Medium — residual: nonlabor − land. Includes energy infrastructure. Depends heavily on land rent assumption</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Savings rate</td>
                            <td style="padding: 4px 8px;">s = 0.20</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Medium (US ~18%, global ~26%)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Cognitive weight</td>
                            <td style="padding: 4px 8px;">θ = 0.68</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: red;">Low (hard to measure cog vs phys split)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Labor ratio scale</td>
                            <td style="padding: 4px 8px;">κ = 1.6</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: red;">Low (calibration artifact)</td>
                        </tr>

                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;" colspan="5"><strong>Substitution Elasticities</strong></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Cog vs Physical</td>
                            <td style="padding: 4px 8px;">ε = 0.70</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: red;">Low (no direct empirical estimates)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Human vs AI (cog)</td>
                            <td style="padding: 4px 8px;">σ_c = 0.80</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: red;">Low — complements (σ&lt;1); wages pinned to AI rental cost via arbitrage at full automation</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Human vs Robot (phys)</td>
                            <td style="padding: 4px 8px;">σ_p = 0.60</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: red;">Low — complements (σ&lt;1); wages pinned to robot rental cost via arbitrage at full automation</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Land substitution</td>
                            <td style="padding: 4px 8px;">σ_L = 0.85</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Medium — high because AI economy is mostly digital; implies Y_max ceiling ~5.8B× with C₂₀₄₀=1000</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;" colspan="5"><strong>Factor Shares (Base Year)</strong></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Land share</td>
                            <td style="padding: 4px 8px;">s_L = 0.06</td>
                            <td style="padding: 4px 8px;">6%</td>
                            <td style="padding: 4px 8px;">5%</td>
                            <td style="padding: 4px 8px; color: red;">Low — MOST UNCERTAIN. Lincoln Institute (land value × cap rate) ~6% US; NIPA rental income ~3.5%; Larson 2015 ~8-10%. Range 3-10%</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Implied return r</td>
                            <td style="padding: 4px 8px;">α × Y₀/K₀</td>
                            <td style="padding: 4px 8px;">9.3%</td>
                            <td style="padding: 4px 8px;">7.0%</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Low-Medium — computed from residual share × (Y/K). Gross r ~15-16%, net r ~10%</td>
                        </tr>

                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;" colspan="5"><strong>Effective Supply Growth to 2040 (× 2025)</strong></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Effective land supply</td>
                            <td style="padding: 4px 8px;">C₂₀₄₀ = 1000×</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: red;">Low — speculative; ~10× urban land expansion (1%→10%) × ~100× better utilization (vertical, density)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;" colspan="5"><strong>Depreciation</strong></td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Productive capital</td>
                            <td style="padding: 4px 8px;">δ_K = 5%</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: green;">High (standard macro)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">AI compute capital</td>
                            <td style="padding: 4px 8px;">δ_C = 30%</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Medium (GPUs depreciate fast but how fast?)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #eee;">
                            <td style="padding: 4px 8px;">Robot capital</td>
                            <td style="padding: 4px 8px;">δ_R = 10%</td>
                            <td style="padding: 4px 8px;" colspan="2">Same for both</td>
                            <td style="padding: 4px 8px; color: #b8860b;">Medium (equipment ~7-15% typical)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </details>

        <!-- Land Bottleneck Toggle -->
        <div style="margin-bottom: 15px; padding: 10px; background: #f0f7ff; border-radius: 4px; border: 1px solid #cce5ff;">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="useLand" checked style="margin-right: 10px; width: 18px; height: 18px;">
                <span style="font-weight: 600; color: #004085;">Land Bottlenecks</span>
                <small style="margin-left: 10px; color: #666;">(Include land as a fixed factor limiting growth)</small>
            </label>
        </div>

        <!-- Taxation Toggle -->
        <div style="margin-bottom: 15px; padding: 10px; background: #fff5f0; border-radius: 4px; border: 1px solid #e5c5c5;">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="useTaxation" checked style="margin-right: 10px; width: 18px; height: 18px;">
                <span style="font-weight: 600; color: #850008;">Taxation</span>
                <small style="margin-left: 10px; color: #666;">(Tax productive capital income, AI services, and robot services)</small>
            </label>
        </div>

        <!-- Predicted Output Toggle -->
        <div style="margin-bottom: 15px; padding: 10px; background: #f5f0ff; border-radius: 4px; border: 1px solid #d0c5e5;">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="usePredictedOutput" checked style="margin-right: 10px; width: 18px; height: 18px;">
                <span style="font-weight: 600; color: #500085;">Predict Output & Productive Capital</span>
                <small style="margin-left: 10px; color: #666;">(Use production function instead of spreadsheet values)</small>
            </label>
        </div>

        <!-- Income Distribution Toggle -->
        <div style="margin-bottom: 15px; padding: 10px; background: #fffff0; border-radius: 4px; border: 1px solid #e5e5c5;">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="useIncomeDistribution" checked style="margin-right: 10px; width: 18px; height: 18px;">
                <span style="font-weight: 600; color: #858500;">Income Distribution</span>
                <small style="margin-left: 10px; color: #666;">(Distribute income across 109 percentile-households with heterogeneous ownership)</small>
            </label>
        </div>

        <h3 class="param-section-title">Choice Parameters (Elasticities)</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="eps">ε (cog vs phys)</label>
                <input type="number" id="eps" value="0.70" step="0.01" min="0.01">
                <small>Substitution between cognitive and physical</small>
            </div>
            <div class="param-group">
                <label for="sig_c">σ_c (human vs AI)</label>
                <input type="number" id="sig_c" value="0.80" step="0.01" min="0.01">
                <small>Substitution human vs AI (cognitive)</small>
            </div>
            <div class="param-group">
                <label for="sig_p">σ_p (human vs robot)</label>
                <input type="number" id="sig_p" value="0.60" step="0.01" min="0.01">
                <small>Substitution human vs robots (physical)</small>
            </div>
            <div class="param-group">
                <label for="omega">ω (labor elasticity)</label>
                <input type="number" id="omega" value="0.2" step="0.1" min="0">
                <small>L_c/L_p = κ · (w_c/w_p)^ω</small>
            </div>
        </div>

        <!-- Land parameters (hidden by default) -->
        <div id="landParams">
            <h3 class="param-section-title">Land Parameters</h3>
            <div class="params-grid">
                <div class="param-group">
                    <label for="s_L">s_L (base-year total land share)</label>
                    <input type="number" id="s_L" value="0.0684" step="0.001" min="0.001" max="0.99">
                    <small>Total land income as % of GDP (~6.8% US, ~8.1% global); scales all category shares proportionally</small>
                </div>
            </div>
            <details style="margin-top: 10px; padding: 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
                <summary style="cursor: pointer; font-weight: 600; color: #333;">
                    Land Category Parameters
                </summary>
                <div style="margin-top: 10px;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #ccc;">
                                <th style="text-align: left; padding: 4px 6px;">Category</th>
                                <th style="padding: 4px 6px;">σ_L</th>
                                <th style="padding: 4px 6px;">η_2040</th>
                                <th style="padding: 4px 6px;">ε_supply</th>
                                <th style="padding: 4px 6px;">p (prot.)</th>
                                <th style="padding: 4px 6px; color: #888;">Area</th>
                                <th style="padding: 4px 6px; color: #888;">GDP%</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 4px 6px;">Agricultural</td>
                                <td style="padding: 4px 6px;"><input type="number" id="sigma_L_agricultural" value="10" step="0.01" min="0.01" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="C_2040_agricultural" value="100" step="1" min="0.01" style="width: 70px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="eps_supply_agricultural" value="0.1" step="0.01" min="0" max="5" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="protect_agricultural" value="0" step="0.01" min="0" max="1" style="width: 55px;"></td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">46.4%</td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">0.20%</td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px;">Urban/Developed</td>
                                <td style="padding: 4px 6px;"><input type="number" id="sigma_L_urban" value="0.95" step="0.01" min="0.01" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="C_2040_urban" value="100" step="1" min="0.01" style="width: 70px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="eps_supply_urban" value="0.05" step="0.01" min="0" max="5" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="protect_urban" value="0" step="0.01" min="0" max="1" style="width: 55px;"></td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">3.3%</td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">4.90%</td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px;">Private Rural</td>
                                <td style="padding: 4px 6px;"><input type="number" id="sigma_L_rural_nonag" value="0.95" step="0.01" min="0.01" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="C_2040_rural_nonag" value="10" step="0.5" min="0.01" style="width: 70px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="eps_supply_rural_nonag" value="0.05" step="0.01" min="0" max="5" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="protect_rural_nonag" value="0" step="0.01" min="0" max="1" style="width: 55px;"></td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">1.7%</td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">0.40%</td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px;">Industrial/Comm.</td>
                                <td style="padding: 4px 6px;"><input type="number" id="sigma_L_industrial" value="0.95" step="0.01" min="0.01" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="C_2040_industrial" value="30" step="0.5" min="0.01" style="width: 70px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="eps_supply_industrial" value="0.05" step="0.01" min="0" max="5" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="protect_industrial" value="0" step="0.01" min="0" max="1" style="width: 55px;"></td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">2.4%</td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">1.30%</td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px;">Wilderness</td>
                                <td style="padding: 4px 6px;"><input type="number" id="sigma_L_wilderness" value="100" step="0.01" min="0.01" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="C_2040_wilderness" value="1" step="0.1" min="0.01" style="width: 70px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="eps_supply_wilderness" value="0.05" step="0.01" min="0" max="5" style="width: 60px;"></td>
                                <td style="padding: 4px 6px;"><input type="number" id="protect_wilderness" value="0.50" step="0.01" min="0" max="1" style="width: 55px;"></td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">46.2%</td>
                                <td style="padding: 4px 6px; color: #888; font-size: 11px;">0.04%</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </details>
        </div>

        <h3 class="param-section-title">Target Parameters</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="alpha">α (capital share incl. energy)</label>
                <input type="number" id="alpha" value="0.36" step="0.01" min="0" max="1">
                <small>CES capital share parameter (includes energy infrastructure)</small>
            </div>
            <div class="param-group">
                <label for="sigma_K">σ_K (capital-labor elasticity)</label>
                <input type="number" id="sigma_K" value="2" step="0.1" min="0.01" max="10">
                <small>CES elasticity: &gt;1 = substitutes (capital share falls as L_eff grows), 1 = Cobb-Douglas, &lt;1 = complements</small>
            </div>
            <div class="param-group">
                <label for="kappa">κ (labor ratio scale)</label>
                <input type="number" id="kappa" value="1.6" step="0.1" min="0.01">
                <small>Scale factor in L_c/L_p</small>
            </div>
            <div class="param-group">
                <label for="theta">θ (cognitive weight)</label>
                <input type="number" id="theta" value="0.68" step="0.01" min="0" max="1">
                <small>Weight on cognitive in L_eff CES</small>
            </div>
        </div>

        <h3 class="param-section-title">Trusted Labor (Human-Only) Sector</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="trust_start_year">Start Year</label>
                <input type="number" id="trust_start_year" value="2029" step="1" min="2025" max="2060">
                <small>Year when trusted labor sector begins</small>
            </div>
            <div class="param-group">
                <label for="trust_num_workers">Initial Workers</label>
                <input type="number" id="trust_num_workers" value="100000" step="5000" min="100">
                <small>Number of trusted-sector workers at start year</small>
            </div>
            <div class="param-group">
                <label for="trust_avg_wage">Avg Wage at Start ($)</label>
                <input type="number" id="trust_avg_wage" value="150000" step="10000" min="1000">
                <small>Per-worker wage at start year</small>
            </div>
            <div class="param-group">
                <label for="trust_sigma">σ_trust (CES elasticity)</label>
                <input type="number" id="trust_sigma" value="0.7" step="0.01" min="0.01" max="10">
                <small>Substitutability with rest of economy; &lt;1 = bottleneck</small>
            </div>
            <div class="param-group">
                <label for="trust_C_2040">Efficiency Multiple (2040)</label>
                <input type="number" id="trust_C_2040" value="2" step="0.1" min="0.1">
                <small>Efficiency per worker by 2040 (like land C_2040)</small>
            </div>
        </div>

        <h3 class="param-section-title">Depreciation Rates</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="delta_K">δ_K (productive capital)</label>
                <input type="number" id="delta_K" value="0.05" step="0.01" min="0" max="1">
                <small>Depreciation of productive capital K_Y</small>
            </div>
            <div class="param-group">
                <label for="delta_C">δ_C (AI capital)</label>
                <input type="number" id="delta_C" value="0.30" step="0.01" min="0" max="1">
                <small>Depreciation of K_C</small>
            </div>
            <div class="param-group">
                <label for="delta_R">δ_R (robot capital)</label>
                <input type="number" id="delta_R" value="0.10" step="0.01" min="0" max="1">
                <small>Depreciation of K_R</small>
            </div>
        </div>

        <!-- Capital accumulation parameters (hidden by default) -->
        <div id="capitalAccumParams">
            <h3 class="param-section-title">Productive Capital Accumulation</h3>
            <div class="params-grid">
                <div class="param-group">
                    <label for="savings_rate">s (savings rate)</label>
                    <input type="number" id="savings_rate" value="0.20" step="0.01" min="0" max="1">
                    <small>Fraction of output saved</small>
                </div>
                <div class="param-group">
                    <label for="initial_KY_ratio">K/Y ratio (base year)</label>
                    <input type="number" id="initial_KY_ratio" value="3.00" step="0.01" min="0.1">
                    <small>Capital-to-output ratio: K₀ = (K/Y) × Y₀</small>
                </div>
                <div class="param-group">
                    <label for="gamma_R">γ_R (robot capital output)</label>
                    <input type="number" id="gamma_R" value="50000" step="10000" min="0">
                    <small>$/robot-human-equiv/year of capital goods produced</small>
                </div>
            </div>
        </div>

        <!-- Tax parameters (now managed via Income Distribution section) -->
        <div id="taxParams"></div>

        <!-- Income Distribution parameters -->
        <div id="incomeDistParams">
            <details style="margin-top: 10px; padding: 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
                <summary style="cursor: pointer; font-weight: 600; color: #333;">
                    Ownership Distribution (Cumulative % Owned by Bottom X%)
                </summary>
                <div style="margin-top: 10px;">
                    <table style="width:100%; border-collapse: collapse; font-size: 13px; margin-bottom: 10px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #ccc;">
                                <th style="text-align:left; padding: 4px 6px;">Asset</th>
                                <th style="padding: 4px 4px;">p1</th>
                                <th style="padding: 4px 4px;">p25</th>
                                <th style="padding: 4px 4px;">p50</th>
                                <th style="padding: 4px 4px;">p75</th>
                                <th style="padding: 4px 4px;">p90</th>
                                <th style="padding: 4px 4px;">p99</th>
                                <th style="padding: 4px 4px;">p99.9</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 4px 6px; font-weight: 600;">Wages</td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_1" value="0.00006" step="0.00001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_25" value="0.034" step="0.005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_50" value="0.1146" step="0.005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_75" value="0.3011" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_90" value="0.5064" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_99" value="0.7756" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_wage_999" value="0.8863" step="0.01" min="0" max="1" style="width:65px;"></td>
                            </tr>
                            <tr style="background: #eee;">
                                <td style="padding: 4px 6px; font-weight: 600;">Capital</td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_1" value="0.0" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_25" value="0.0" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_50" value="0.025" step="0.005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_75" value="0.10" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_90" value="0.326" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_99" value="0.69" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_capital_999" value="0.861" step="0.01" min="0" max="1" style="width:65px;"></td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px; font-weight: 600;">AI</td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_1" value="0.0" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_25" value="0.0005" step="0.0001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_50" value="0.003" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_75" value="0.015" step="0.005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_90" value="0.05" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_99" value="0.25" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_ai_999" value="0.50" step="0.01" min="0" max="1" style="width:65px;"></td>
                            </tr>
                            <tr style="background: #eee;">
                                <td style="padding: 4px 6px; font-weight: 600;">Robots</td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_1" value="0.0" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_25" value="0.001" step="0.0005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_50" value="0.005" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_75" value="0.025" step="0.005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_90" value="0.08" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_99" value="0.35" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_robot_999" value="0.60" step="0.01" min="0" max="1" style="width:65px;"></td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px; font-weight: 600;">Land</td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_1" value="0.0" step="0.001" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_25" value="0.015" step="0.005" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_50" value="0.098" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_75" value="0.30" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_90" value="0.559" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_99" value="0.865" step="0.01" min="0" max="1" style="width:65px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="cdf_land_999" value="0.96" step="0.01" min="0" max="1" style="width:65px;"></td>
                            </tr>
                        </tbody>
                    </table>
                    <small style="color: #666;">Cumulative Lorenz shares as fractions. Wages: IRS SOI TY2022 AGI by percentile. Capital/Land: Fed DFA Q2 2025. AI/Robot: estimated from equity ownership concentration.</small>
                </div>
            </details>
            <details style="margin-top: 10px; padding: 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
                <summary style="cursor: pointer; font-weight: 600; color: #333;">
                    Income Distribution Curves (Multiplier of Mean at Percentile)
                </summary>
                <div style="margin-top: 10px;">
                    <table style="width:100%; border-collapse: collapse; font-size: 13px; margin-bottom: 10px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #ccc;">
                                <th style="text-align:left; padding: 4px 6px;">Source</th>
                                <th style="padding: 4px 4px;">p5</th>
                                <th style="padding: 4px 4px;">p10</th>
                                <th style="padding: 4px 4px;">p25</th>
                                <th style="padding: 4px 4px;">p50</th>
                                <th style="padding: 4px 4px;">p75</th>
                                <th style="padding: 4px 4px;">p90</th>
                                <th style="padding: 4px 4px;">p95</th>
                                <th style="padding: 4px 4px;">p99</th>
                                <th style="padding: 4px 4px;">p99.9</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 4px 6px; font-weight: 600;">Wages</td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_5" value="0.04" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_10" value="0.10" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_25" value="0.28" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_50" value="0.62" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_75" value="1.20" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_90" value="2.10" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_95" value="3.30" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_99" value="8.50" step="0.5" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_wage_999" value="40.0" step="1" min="0" style="width:58px;"></td>
                            </tr>
                            <tr style="background: #eee;">
                                <td style="padding: 4px 6px; font-weight: 600;">Capital</td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_5" value="0.0" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_10" value="0.0" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_25" value="0.02" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_50" value="0.10" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_75" value="0.45" step="0.05" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_90" value="1.80" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_95" value="4.00" step="0.5" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_99" value="12.0" step="1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_capital_999" value="80.0" step="5" min="0" style="width:58px;"></td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px; font-weight: 600;">AI</td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_5" value="0.0" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_10" value="0.0" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_25" value="0.005" step="0.001" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_50" value="0.02" step="0.005" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_75" value="0.10" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_90" value="0.50" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_95" value="2.50" step="0.5" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_99" value="10.0" step="1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_ai_999" value="60.0" step="5" min="0" style="width:58px;"></td>
                            </tr>
                            <tr style="background: #eee;">
                                <td style="padding: 4px 6px; font-weight: 600;">Robots</td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_5" value="0.0" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_10" value="0.0" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_25" value="0.005" step="0.001" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_50" value="0.02" step="0.005" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_75" value="0.10" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_90" value="0.50" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_95" value="2.50" step="0.5" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_99" value="10.0" step="1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_robot_999" value="60.0" step="5" min="0" style="width:58px;"></td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 6px; font-weight: 600;">Land</td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_5" value="0.02" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_10" value="0.06" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_25" value="0.20" step="0.01" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_50" value="0.55" step="0.05" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_75" value="1.10" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_90" value="2.00" step="0.1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_95" value="3.50" step="0.5" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_99" value="8.00" step="1" min="0" style="width:58px;"></td>
                                <td style="padding: 4px 2px;"><input type="number" id="mult_land_999" value="30.0" step="5" min="0" style="width:58px;"></td>
                            </tr>
                        </tbody>
                    </table>
                    <small style="color: #666;">Income at percentile p = multiplier × mean. E.g. wage multiplier 0.62 at p50 means median earner gets 62% of mean wage. Used for distribution charts only (Gini uses Lorenz above).</small>
                </div>
            </details>
            <h3 class="param-section-title">Labor Supply Parameters</h3>
            <div class="params-grid hidden" id="psiParams">
                <div class="param-group">
                    <label for="psi">ψ (labor supply elasticity)</label>
                    <input type="number" id="psi" value="0.5" step="0.1" min="0.01">
                    <small>L = B · w̄^(1/ψ); higher = less responsive. Used when Income Distribution is off.</small>
                </div>
            </div>
            <div class="params-grid" id="lfpParams">
                <div class="param-group">
                    <label for="lfp_target">LFP target (base year)</label>
                    <input type="number" id="lfp_target" value="0.62" step="0.01" min="0.01" max="0.99">
                    <small>Base-year labor force participation rate at today's wage</small>
                </div>
                <div class="param-group">
                    <label for="logistic_s">Logistic steepness (s)</label>
                    <input type="number" id="logistic_s" value="0.7" step="0.1" min="0.1">
                    <small>How sharply participation drops as wages fall; higher = steeper cliff</small>
                </div>
                <div class="param-group">
                    <label for="k_ubi">UBI dampener (k)</label>
                    <input type="number" id="k_ubi" value="1.13" step="0.01" min="0">
                    <small>LFP × exp(−k · UBI/wage); k=1.13 → LFP ≈ 20% when UBI = wage</small>
                </div>
                <div class="param-group">
                    <label for="labor_damp">Labor iteration damping</label>
                    <input type="number" id="labor_damp" value="0.5" step="0.05" min="0.05" max="1.0">
                    <small>Blend factor for labor convergence loop (0.05 = slow, 1.0 = no damping)</small>
                </div>
            </div>
            <h3 class="param-section-title">Taxation & UBI</h3>
            <div class="params-grid">
                <div class="param-group">
                    <label for="ubi_start_year">Capital Tax + UBI Start Year</label>
                    <input type="number" id="ubi_start_year" value="2033" step="1" min="2025" max="2060">
                    <small>Year when capital taxes & UBI begin</small>
                </div>
                <div class="param-group">
                    <label for="tau_k">τ_k (capital income tax)</label>
                    <input type="number" id="tau_k" value="0" step="0.01" min="0" max="0.99">
                    <small>Tax on productive capital income</small>
                </div>
                <div class="param-group">
                    <label for="tau_AI">τ_AI (AI services tax)</label>
                    <input type="number" id="tau_AI" value="0.10" step="0.01" min="0" max="0.99">
                    <small>Tax on AI service revenue</small>
                </div>
                <div class="param-group">
                    <label for="tau_R">τ_R (robot services tax)</label>
                    <input type="number" id="tau_R" value="0.10" step="0.01" min="0" max="0.99">
                    <small>Tax on robot service revenue</small>
                </div>
                <div class="param-group">
                    <label for="ubi_share_us">UBI Share (US)</label>
                    <input type="number" id="ubi_share_us" value="0.50" step="0.01" min="0" max="1">
                    <small>Fraction of tax revenue to US UBI</small>
                </div>
                <div class="param-group">
                    <label for="ubi_share_world">UBI Share (World ex-China)</label>
                    <input type="number" id="ubi_share_world" value="0.30" step="0.01" min="0" max="1">
                    <small>Fraction of tax revenue to world ex-China UBI</small>
                </div>
            </div>
        </div>

        <h3 class="param-section-title">Base-Year Economy (2025)</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="base_Y">Y₀ (GDP / Output)</label>
                <input type="text" id="base_Y" value="30.6T">
                <small>Base-year output (supports K/M/B/T suffixes)</small>
            </div>
            <div class="param-group">
                <label for="base_L">L₀ (Labor Force)</label>
                <input type="text" id="base_L" value="168.6M">
                <small>Base-year human labor force</small>
            </div>
            <div class="param-group">
                <label for="base_WAP">WAP₀ (Working Age Population)</label>
                <input type="text" id="base_WAP" value="270.7M">
                <small>Base-year working age population</small>
            </div>
        </div>

        <button id="runModel">Run Model</button>
    </div>

    <div class="charts-section">
        <div class="chart-container">
            <h3>Wages per Human Equivalent Worker</h3>
            <canvas id="wagesChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Rental Costs over Time</h3>
            <canvas id="rentalCostChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Automated Task Shares (1-μ terms)</h3>
            <canvas id="muChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Human Labor Allocation</h3>
            <canvas id="ellChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Productive Capital Allocation Shares</h3>
            <canvas id="capitalChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Returns to Productive Capital over Time</h3>
            <canvas id="interestChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Factor Income Shares of GWP</h3>
            <canvas id="factorIncomeChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>(Implied) Technology Levels</h3>
            <canvas id="techChart"></canvas>
        </div>
        <div class="chart-container" id="landRentContainer" style="display: none;">
            <h3>Land Rent per Hectare ($/ha/year)</h3>
            <canvas id="landRentChart"></canvas>
        </div>
        <div class="chart-container" id="landUseShareContainer" style="display: none;">
            <h3>Physical Land Use Shares by Category</h3>
            <canvas id="landUseShareChart"></canvas>
        </div>
        <div class="chart-container" id="landIncomeShareContainer" style="display: none;">
            <h3>Land Income Shares by Category</h3>
            <canvas id="landIncomeShareChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Labor Force and Working Age Population</h3>
            <canvas id="laborChart"></canvas>
        </div>
        <div class="chart-container" id="incomeChartsContainer" style="display: none; grid-column: span 2;">
            <h3>Household Income per Worker</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div><canvas id="wageIncomeChart"></canvas></div>
                <div id="ubiTransferChartContainer" style="display: none;"><canvas id="ubiTransferChart"></canvas></div>
            </div>
        </div>
        <div class="chart-container">
            <h3>Output: Forecast vs Model Prediction</h3>
            <canvas id="outputChart"></canvas>
        </div>
        <div class="chart-container" id="incomeDistContainer" style="display: none; grid-column: span 2;">
            <h3>Household Income Distribution (109 Percentiles)</h3>
            <canvas id="incomeDistChart"></canvas>
        </div>
        <div class="chart-container" id="incomeCompContainer" style="display: none; grid-column: span 2;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 5px;">
                <h3 style="margin: 0;">Income Composition by Percentile</h3>
                <select id="incomeCompYearSelect" style="padding: 4px 8px; font-size: 14px;"></select>
            </div>
            <canvas id="incomeCompChart"></canvas>
        </div>
        <div class="chart-container" id="netWorthContainer" style="display: none; grid-column: span 2;">
            <h3>Household Net Worth Distribution (109 Percentiles)</h3>
            <canvas id="netWorthChart"></canvas>
        </div>
        <div class="chart-container" id="giniContainer" style="display: none;">
            <h3>Gini Coefficients Over Time</h3>
            <canvas id="giniChart"></canvas>
        </div>
    </div>

    <div id="resultsTable" class="results-table hidden">
        <h3>Detailed Results</h3>
        <div id="tableContainer"></div>
    </div>

    <script>
    // ========================================
    // Template Data for Editable Table
    // ========================================

    const TEMPLATE_YEARS = [2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040];

    // Editable rows shown in the table (6 core + 2 conditional share rows)
    const TEMPLATE_ROWS = [
        {
            label: "Human Equiv. AI Cognitive Workforce",
            values: null,
            derived: true, bold: true,
            compute: function(rows) {
                var a = rows["AI Copies"], b = rows["Human-equivs per AI Copy"];
                if (!a || !b) return null;
                return a.map(function(v, i) { return v * b[i]; });
            }
        },
        {
            label: "Human Equiv. Robotic Physical Workforce",
            values: null,
            derived: true, bold: true,
            compute: function(rows) {
                var a = rows["Robots"], b = rows["Human-equivs per Robot"];
                if (!a || !b) return null;
                return a.map(function(v, i) { return v * b[i]; });
            }
        },
        {
            label: "AI Copies",
            values: ["51.9M","79.4M","114.6M","161.6M","171.1M","212.6M","313.3M","747.9M","2.1B","6.8B","25.9B","89.4B","180.7B","361.4B","719.6B","1.4T"]
        },
        {
            label: "Human-equivs per AI Copy",
            values: ["0.005","0.01","0.04","0.13","0.38","1.13","3.36","10.0","29.78","88.69","264.13","157.64","94.08","56.15","33.51","20"]
        },
        {
            label: "AI Copies per H100e",
            values: null,
            derived: true,
            compute: function() {
                return H100E_PER_AI_COPY.map(function(v) { return 1.0 / v; });
            }
        },
        {
            label: "Robots",
            values: ["2.0K","6.0K","18.0K","54.0K","162.0K","648.0K","2.6M","13.0M","64.8M","324.0M","972.0M","4.9B","24.3B","121.5B","607.5B","3.0T"]
        },
        {
            label: "Human-equivs per Robot",
            values: ["0.002","0.005","0.01","0.04","0.12","0.37","1.11","3.33","10","30","90","99","108.9","119.79","131.769","144.9459"]
        },
        {
            label: "Cognitive Automation Frontier",
            bold: true,
            values: ["2%","3%","5%","17%","38%","52%","65%","78%","92%","100%","100%","100%","100%","100%","100%","100%"]
        },
        {
            label: "Physical Automation Frontier",
            bold: true,
            values: ["2%","2%","2%","2%","5%","17%","38%","52%","65%","78%","92%","100%","100%","100%","100%","100%"]
        },
    ];

    // Share rows (shown only in US mode)
    const US_SHARE_ROWS = [
        {
            label: "US Share of Compute",
            values: ["80%","80%","80%","80%","80%","80%","80%","80%","80%","80%","80%","80%","80%","80%","80%","80%"]
        },
        {
            label: "US Share of Robots",
            values: ["20%","20%","20%","20%","20%","20%","20%","20%","20%","20%","20%","20%","20%","20%","20%","20%"]
        }
    ];

    // H100 equivalents required per AI copy (from Plan A&B CSV row 5)
    const H100E_PER_AI_COPY = [0.05, 0.08, 0.14, 0.23, 0.39, 0.65, 1.08, 1.80, 3.00, 5.00, 8.34, 13.91, 23.21, 38.71, 64.58, 107.72];

    // Background defaults for US economy
    const BACKGROUND_DEFAULTS_US = {
        "Human Working Age Population": ["270.7M","273.4M","276.1M","278.9M","281.7M","284.5M","287.3M","290.2M","293.1M","296.0M","299.0M","302.0M","305.0M","308.1M","311.1M","314.3M"],
        "Human Labor Force": ["168.6M","169.0M","169.3M","169.6M","169.8M","167.3M","167.3M","157.5M","141.6M","141.6M","113.7M","85.3M","56.2M","41.7M","36.0M","33.3M"],
        "Output": ["30.6T","31.2T","32T","33T","33.5T","34.5T","36.5T","39.5T","45.5T","63T","120T","205T","373T","710T","1375T","2710T"],
        "Capital": ["91.8T","93T","94T","95T","96T","97T","98T","99T","101T","104T","110T","125T","154T","210T","320T","538T"]
    };

    // Background defaults for Global economy (placeholder — to be updated)
    const BACKGROUND_DEFAULTS_GLOBAL = {
        "Human Working Age Population": ["5.1B","5.1B","5.2B","5.2B","5.3B","5.3B","5.4B","5.4B","5.5B","5.5B","5.6B","5.6B","5.7B","5.7B","5.8B","5.8B"],
        "Human Labor Force": ["3.5B","3.5B","3.5B","3.6B","3.6B","3.6B","3.6B","3.4B","3.1B","3.1B","2.5B","1.9B","1.2B","0.9B","0.8B","0.7B"],
        "Output": ["117T","120T","124T","128T","132T","137T","144T","155T","179T","249T","475T","811T","1477T","2804T","5438T","10715T"],
        "Capital": ["410T","414T","418T","422T","427T","432T","438T","444T","452T","465T","490T","556T","685T","932T","1420T","2384T"]
    };

    function isUSMode() {
        return document.getElementById('useUSMode').checked;
    }

    // ========================================
    // Economic Model (ported from Python)
    // ========================================

    const TINY = 1e-12;

    // ========================================
    // 5-CATEGORY LAND CONSTANTS
    // ========================================
    const LAND_CATEGORIES = ['agricultural', 'urban', 'rural_nonag', 'industrial', 'wilderness'];
    const LAND_CATEGORY_LABELS = {
        agricultural: 'Agricultural',
        urban: 'Urban/Developed',
        rural_nonag: 'Private Rural Non-Ag',
        industrial: 'Industrial/Commercial',
        wilderness: 'Uninhabited/Wilderness'
    };

    // Physical areas in hectares (base year 2025, fixed)
    const LAND_AREAS_US = {
        agricultural: 424.3e6,
        urban: 30.2e6,
        rural_nonag: 15.5e6,
        industrial: 22.0e6,
        wilderness: 422.7e6
    };
    const LAND_AREAS_WORLD = {
        agricultural: 4316e6,
        urban: 117e6,
        rural_nonag: 52e6,
        industrial: 39e6,
        wilderness: 8479e6
    };
    const TOTAL_LAND_HA_US = 914.7e6;
    const TOTAL_LAND_HA_WORLD = 13003e6;

    // Target base-year GDP shares per land category (income as % of GDP)
    // Used to calibrate conditional CES share parameters s_i
    const LAND_GDP_SHARES_US = {
        agricultural: 0.0020,
        urban: 0.049,
        rural_nonag: 0.004,
        industrial: 0.013,
        wilderness: 0.0004
    };
    const LAND_GDP_SHARES_WORLD = {
        agricultural: 0.006,
        urban: 0.034,
        rural_nonag: 0.009,
        industrial: 0.030,
        wilderness: 0.0015
    };

    // Chart colors for 5 categories
    const LAND_COLORS = {
        agricultural: { border: 'rgb(34, 139, 34)', bg: 'rgba(34, 139, 34, 0.8)' },
        urban: { border: 'rgb(139, 69, 19)', bg: 'rgba(139, 69, 19, 0.8)' },
        rural_nonag: { border: 'rgb(70, 130, 180)', bg: 'rgba(70, 130, 180, 0.8)' },
        industrial: { border: 'rgb(178, 34, 34)', bg: 'rgba(178, 34, 34, 0.8)' },
        wilderness: { border: 'rgb(46, 139, 87)', bg: 'rgba(46, 139, 87, 0.8)' }
    };

    // Check if land mode is enabled
    function isLandMode() {
        return document.getElementById('useLand').checked;
    }

    // Check if endogenous labor supply is enabled


    // Check if taxation is enabled
    function isTaxationMode() {
        return document.getElementById('useTaxation').checked;
    }

    // Check if predicted output mode is enabled
    function isPredictedOutputMode() {
        return document.getElementById('usePredictedOutput').checked;
    }

    // Check if income distribution mode is enabled
    function isIncomeDistributionMode() {
        return document.getElementById('useIncomeDistribution').checked;
    }

    // Get parameters from inputs
    function getParams() {
        const params = {
            alpha: parseFloat(document.getElementById('alpha').value),
            eps: parseFloat(document.getElementById('eps').value),
            sig_c: parseFloat(document.getElementById('sig_c').value),
            sig_p: parseFloat(document.getElementById('sig_p').value),
            kappa: parseFloat(document.getElementById('kappa').value),
            omega: parseFloat(document.getElementById('omega').value),
            theta: parseFloat(document.getElementById('theta').value),
            psi: parseFloat(document.getElementById('psi').value),
            // Depreciation rates
            delta_K: parseFloat(document.getElementById('delta_K').value),
            delta_C: parseFloat(document.getElementById('delta_C').value),
            delta_R: parseFloat(document.getElementById('delta_R').value),
            sigma_K: parseFloat(document.getElementById('sigma_K').value)
        };

        // Trusted labor params (always on)
        params.trust_start_year = parseInt(document.getElementById('trust_start_year').value);
        params.trust_num_workers = parseFloat(document.getElementById('trust_num_workers').value);
        params.trust_avg_wage = parseFloat(document.getElementById('trust_avg_wage').value);
        params.trust_initial_value = params.trust_num_workers * params.trust_avg_wage;
        params.trust_sigma = parseFloat(document.getElementById('trust_sigma').value);
        params.trust_C_2040 = parseFloat(document.getElementById('trust_C_2040').value);

        if (isLandMode()) {
            params.s_L = parseFloat(document.getElementById('s_L').value);
            params.sigma_L_land = {};
            params.C_2040_land = {};
            params.epsilon_supply = {};
            params.protect_land = {};
            for (var c = 0; c < LAND_CATEGORIES.length; c++) {
                var cat = LAND_CATEGORIES[c];
                params.sigma_L_land[cat] = parseFloat(document.getElementById('sigma_L_' + cat).value);
                params.C_2040_land[cat] = parseFloat(document.getElementById('C_2040_' + cat).value);
                params.epsilon_supply[cat] = parseFloat(document.getElementById('eps_supply_' + cat).value);
                params.protect_land[cat] = parseFloat(document.getElementById('protect_' + cat).value);
            }
        }

        if (isTaxationMode()) {
            params.tau_k = parseFloat(document.getElementById('tau_k').value);
            params.tau_AI = parseFloat(document.getElementById('tau_AI').value);
            params.tau_R = parseFloat(document.getElementById('tau_R').value);
            params.ubi_start_year = parseInt(document.getElementById('ubi_start_year').value);
            params.ubi_share_us = parseFloat(document.getElementById('ubi_share_us').value);
            params.ubi_share_world = parseFloat(document.getElementById('ubi_share_world').value);
        } else {
            // Default to zero taxes
            params.tau_k = 0;
            params.tau_AI = 0;
            params.tau_R = 0;
            params.ubi_start_year = 9999;
            params.ubi_share_us = 0;
            params.ubi_share_world = 0;
        }

        if (isPredictedOutputMode()) {
            params.savings_rate = parseFloat(document.getElementById('savings_rate').value);
            params.initial_KY_ratio = parseFloat(document.getElementById('initial_KY_ratio').value);
            params.gamma_R = parseFloat(document.getElementById('gamma_R').value);
        }

        if (isIncomeDistributionMode()) {
            // Read empirical CDF breakpoints for each asset class
            // Each is [L(0.01), L(0.25), L(0.50), L(0.75), L(0.90), L(0.99), L(0.999)]
            params.cdf_wage = [
                parseFloat(document.getElementById('cdf_wage_1').value),
                parseFloat(document.getElementById('cdf_wage_25').value),
                parseFloat(document.getElementById('cdf_wage_50').value),
                parseFloat(document.getElementById('cdf_wage_75').value),
                parseFloat(document.getElementById('cdf_wage_90').value),
                parseFloat(document.getElementById('cdf_wage_99').value),
                parseFloat(document.getElementById('cdf_wage_999').value)
            ];
            params.cdf_capital = [
                parseFloat(document.getElementById('cdf_capital_1').value),
                parseFloat(document.getElementById('cdf_capital_25').value),
                parseFloat(document.getElementById('cdf_capital_50').value),
                parseFloat(document.getElementById('cdf_capital_75').value),
                parseFloat(document.getElementById('cdf_capital_90').value),
                parseFloat(document.getElementById('cdf_capital_99').value),
                parseFloat(document.getElementById('cdf_capital_999').value)
            ];
            params.cdf_ai = [
                parseFloat(document.getElementById('cdf_ai_1').value),
                parseFloat(document.getElementById('cdf_ai_25').value),
                parseFloat(document.getElementById('cdf_ai_50').value),
                parseFloat(document.getElementById('cdf_ai_75').value),
                parseFloat(document.getElementById('cdf_ai_90').value),
                parseFloat(document.getElementById('cdf_ai_99').value),
                parseFloat(document.getElementById('cdf_ai_999').value)
            ];
            params.cdf_robot = [
                parseFloat(document.getElementById('cdf_robot_1').value),
                parseFloat(document.getElementById('cdf_robot_25').value),
                parseFloat(document.getElementById('cdf_robot_50').value),
                parseFloat(document.getElementById('cdf_robot_75').value),
                parseFloat(document.getElementById('cdf_robot_90').value),
                parseFloat(document.getElementById('cdf_robot_99').value),
                parseFloat(document.getElementById('cdf_robot_999').value)
            ];
            params.cdf_land = [
                parseFloat(document.getElementById('cdf_land_1').value),
                parseFloat(document.getElementById('cdf_land_25').value),
                parseFloat(document.getElementById('cdf_land_50').value),
                parseFloat(document.getElementById('cdf_land_75').value),
                parseFloat(document.getElementById('cdf_land_90').value),
                parseFloat(document.getElementById('cdf_land_99').value),
                parseFloat(document.getElementById('cdf_land_999').value)
            ];
            // Income multiplier curves for distribution charts
            var _mp = [5, 10, 25, 50, 75, 90, 95, 99, 99.9];
            function readMults(prefix) {
                var pctIds = ['5','10','25','50','75','90','95','99','999'];
                return { pcts: _mp, vals: pctIds.map(function(s) { return parseFloat(document.getElementById(prefix + s).value) || 0; }) };
            }
            params.mult_wage = readMults('mult_wage_');
            params.mult_capital = readMults('mult_capital_');
            params.mult_ai = readMults('mult_ai_');
            params.mult_robot = readMults('mult_robot_');
            params.mult_land = readMults('mult_land_');

            // Distribution always reads tax/UBI params (independent of taxation toggle)
            params.dist_tau_k = parseFloat(document.getElementById('tau_k').value);
            params.dist_tau_AI = parseFloat(document.getElementById('tau_AI').value);
            params.dist_tau_R = parseFloat(document.getElementById('tau_R').value);
            params.dist_ubi_start_year = parseInt(document.getElementById('ubi_start_year').value);
            params.dist_ubi_share_us = parseFloat(document.getElementById('ubi_share_us').value);
            params.dist_ubi_share_world = parseFloat(document.getElementById('ubi_share_world').value);

            // LFP model parameters
            params.lfp_target = parseFloat(document.getElementById('lfp_target').value);
            params.logistic_s = parseFloat(document.getElementById('logistic_s').value);
            params.k_ubi = parseFloat(document.getElementById('k_ubi').value);
            params.labor_damp = parseFloat(document.getElementById('labor_damp').value);
        }

        return params;
    }

    // ========================================
    // 5-CATEGORY LAND MODEL: SEQUENTIAL CES NESTING
    // ========================================
    // Each land category i has its own σ_i and s_i.
    // Y_hat → CES(Y, C_1*M̃_1; s_1, σ_1) → CES(→, C_2*M̃_2; ...) → ... → Y_final
    // Nesting order: LAND_NESTING_ORDER (smallest share first).
    // M̃_i normalized so C_i*M̃_i = Y_{i-1} at base year → Y_i = Y_{i-1}, Y_final = Y_hat.
    // s_i is the CES share at nesting level i; GDP_share_i = s_i × Π_{j after i}(1-s_j).

    const LAND_NESTING_ORDER = ['wilderness', 'rural_nonag', 'industrial', 'agricultural', 'urban'];

    // Two-input CES: Z = [s × X1^ρ + (1-s) × X2^ρ]^(1/ρ)
    // X1 = land input, X2 = upstream aggregate
    function ces2(X_land, X_agg, s, sigma) {
        X_land = Math.max(X_land, TINY);
        X_agg = Math.max(X_agg, TINY);
        s = Math.max(TINY, Math.min(s, 1.0 - TINY));
        if (Math.abs(sigma - 1.0) < 1e-10) {
            return Math.pow(X_land, s) * Math.pow(X_agg, 1.0 - s);
        }
        var rho = (sigma - 1.0) / sigma;
        var term1 = s * Math.pow(X_land, rho);
        var term2 = (1.0 - s) * Math.pow(X_agg, rho);
        return Math.pow(term1 + term2, 1.0 / rho);
    }

    // Marginal product of land input in a 2-input CES: dZ/dX_land = s × (X_land)^(ρ-1) × Z^(1-ρ)
    function ces2_dZ_dXland(Z, X_land, s, sigma) {
        Z = Math.max(Z, TINY);
        X_land = Math.max(X_land, TINY);
        s = Math.max(TINY, Math.min(s, 1.0 - TINY));
        if (Math.abs(sigma - 1.0) < 1e-10) {
            return s * Z / X_land;
        }
        var rho = (sigma - 1.0) / sigma;
        return s * Math.pow(X_land, rho - 1.0) * Math.pow(Z, 1.0 - rho);
    }

    // Marginal product of upstream aggregate: dZ/dX_agg = (1-s) × (X_agg)^(ρ-1) × Z^(1-ρ)
    function ces2_dZ_dXagg(Z, X_agg, s, sigma) {
        Z = Math.max(Z, TINY);
        X_agg = Math.max(X_agg, TINY);
        s = Math.max(TINY, Math.min(s, 1.0 - TINY));
        if (Math.abs(sigma - 1.0) < 1e-10) {
            return (1.0 - s) * Z / X_agg;
        }
        var rho = (sigma - 1.0) / sigma;
        return (1.0 - s) * Math.pow(X_agg, rho - 1.0) * Math.pow(Z, 1.0 - rho);
    }

    // Compute Y_final from Y_hat by applying sequential CES nests
    // landParams must have: nesting_order, M_vec, C_vec, s_vec, sigma_vec
    // Returns { Y_final, Y_levels: {cat: Y_i}, Y_inputs: {cat: Y_{i-1}} }
    function sequentialLandCES(Yhat, landParams) {
        var Y_cur = Math.max(Yhat, TINY);
        var Y_levels = {};
        var Y_inputs = {};
        var order = LAND_NESTING_ORDER;
        for (var i = 0; i < order.length; i++) {
            var cat = order[i];
            var X_land = landParams.C_vec[cat] * landParams.M_vec[cat];
            Y_inputs[cat] = Y_cur;
            Y_cur = ces2(X_land, Y_cur, landParams.s_vec[cat], landParams.sigma_vec[cat]);
            Y_levels[cat] = Y_cur;
        }
        return { Y_final: Y_cur, Y_levels: Y_levels, Y_inputs: Y_inputs };
    }

    // Compute shadow price P_Y = dY_final/dY_hat (chain rule through all nests)
    function sequentialLandPY(landResult, landParams) {
        var order = LAND_NESTING_ORDER;
        var PY = 1.0;
        for (var i = 0; i < order.length; i++) {
            var cat = order[i];
            var Y_i = landResult.Y_levels[cat];
            var Y_input = landResult.Y_inputs[cat];
            PY *= ces2_dZ_dXagg(Y_i, Y_input, landParams.s_vec[cat], landParams.sigma_vec[cat]);
        }
        return PY;
    }

    // Compute rent per scaled-M̃ unit for each category (dY_final/dM̃_i)
    function sequentialLandRents(landResult, landParams) {
        var order = LAND_NESTING_ORDER;
        var v = {};
        for (var i = 0; i < order.length; i++) {
            var cat = order[i];
            var X_land = landParams.C_vec[cat] * landParams.M_vec[cat];
            var Y_i = landResult.Y_levels[cat];
            // dY_i / d(C_i*M̃_i) at this nesting level
            var dYi_dXland = ces2_dZ_dXland(Y_i, X_land, landParams.s_vec[cat], landParams.sigma_vec[cat]);
            // Chain rule: dY_final/dY_i = Π_{j > i} dY_j/dY_{j-1}
            var chain = 1.0;
            for (var j = i + 1; j < order.length; j++) {
                var cat_j = order[j];
                var Y_j = landResult.Y_levels[cat_j];
                var Y_j_input = landResult.Y_inputs[cat_j];
                chain *= ces2_dZ_dXagg(Y_j, Y_j_input, landParams.s_vec[cat_j], landParams.sigma_vec[cat_j]);
            }
            // dY_final/dM̃_i = chain × dYi_dXland × C_i
            v[cat] = chain * dYi_dXland * landParams.C_vec[cat];
        }
        return v;
    }

    // Calibrate conditional share parameters s_i from GDP shares
    // GDP_share_i = s_i × Π_{j nested after i} (1 - s_j)
    // Solve from last (outermost) to first (innermost)
    function calibrateConditionalShares(gdpShares) {
        var s_vec = {};
        var order = LAND_NESTING_ORDER;
        // Work backwards: last in nesting order has s_i = GDP_share_i
        var productTail = 1.0;
        for (var i = order.length - 1; i >= 0; i--) {
            var cat = order[i];
            s_vec[cat] = gdpShares[cat] / productTail;
            productTail *= (1.0 - s_vec[cat]);
        }
        return s_vec;
    }

    // Per-category land efficiency multiplier η_i(t)
    function computeLandProductivity_i(year, baseYear, C_2040_i) {
        var yearsSinceBase = year - baseYear;
        if (yearsSinceBase <= 0) return 1.0;
        var g_c = Math.log(C_2040_i) / 15;
        return Math.exp(g_c * yearsSinceBase);
    }

    // ========================================
    // TRUSTED LABOR SECTOR HELPERS
    // ========================================

    // Efficiency multiplier for trusted labor (linear ramp like land C_2040)
    function computeTrustEfficiency(year, startYear, C_2040) {
        var yearsSinceStart = year - startYear;
        if (yearsSinceStart <= 0) return 1.0;
        var yearsTo2040 = 2040 - startYear;
        if (yearsTo2040 <= 0) return C_2040;
        // Linear interpolation: 1.0 at startYear, C_2040 at 2040, extrapolate beyond
        return 1.0 + (C_2040 - 1.0) * yearsSinceStart / yearsTo2040;
    }

    // Calibrate s_trust so that trusted sector earns target_income at given Y_hat and X_trust
    // CES2: Y_combined = [s * X_trust^rho + (1-s) * Y_hat^rho]^(1/rho)
    // Trust income = dY/dX_trust * X_trust = s * X_trust^rho * Y_combined^(1-rho) * X_trust^(rho-1) * X_trust
    //             = s * X_trust^rho * Y_combined / (s * X_trust^rho + (1-s) * Y_hat^rho)
    // Setting trust_income / Y_combined = target_share, solve for s:
    //   target_share = s * X_trust^rho / (s * X_trust^rho + (1-s) * Y_hat^rho)
    //   target_share * (s * X^rho + (1-s) * Y^rho) = s * X^rho
    //   target_share * (1-s) * Y^rho = s * X^rho * (1 - target_share)
    //   s = target_share * Y^rho / (target_share * Y^rho + (1 - target_share) * X^rho)
    function calibrateTrustShare(Y_hat, X_trust, target_income, sigma) {
        Y_hat = Math.max(Y_hat, TINY);
        X_trust = Math.max(X_trust, TINY);
        var target_share = Math.max(TINY, Math.min(1.0 - TINY, target_income / Y_hat));
        if (Math.abs(sigma - 1.0) < 1e-10) {
            // Cobb-Douglas: s_trust = target_share directly
            return target_share;
        }
        var rho = (sigma - 1.0) / sigma;
        var Xr = Math.pow(X_trust, rho);
        var Yr = Math.pow(Y_hat, rho);
        var s = target_share * Yr / (target_share * Yr + (1.0 - target_share) * Xr);
        return Math.max(TINY, Math.min(1.0 - TINY, s));
    }

    // Endogenous land reallocation via supply elasticity.
    // ε_supply_i controls how responsive category i's area is to price signals:
    //   ΔM_i/M_i = ε_supply_i × (rent_i / avg_rent - 1)
    // High ε = easy to repurpose (farmland → solar). Low ε = hard (build new city).
    // p_i enforces a hard floor: category i can never drop below p_i × M_initial_i hectares.
    // rent_per_ha is in $/physical-ha. Returns new M_physical (total area conserved).
    function reallocateLand(M_physical, rent_per_ha, epsilon_supply, protect_vec, M_initial) {
        var totalLand = 0;
        var totalRent = 0;
        for (var c = 0; c < LAND_CATEGORIES.length; c++) {
            var cat = LAND_CATEGORIES[c];
            totalLand += M_physical[cat];
            totalRent += Math.max(rent_per_ha[cat] || 0, 0) * M_physical[cat];
        }
        if (totalRent <= 0 || totalLand <= 0) return Object.assign({}, M_physical);

        // Average rent per hectare (area-weighted)
        var avgRent = totalRent / totalLand;

        // Compute desired fractional change for each category
        var desiredChange = {};
        for (var c = 0; c < LAND_CATEGORIES.length; c++) {
            var cat = LAND_CATEGORIES[c];
            var rent_ratio = Math.max(rent_per_ha[cat] || 0, 0) / Math.max(avgRent, TINY);
            desiredChange[cat] = epsilon_supply[cat] * (rent_ratio - 1.0);
        }

        // Apply desired changes, then separate into shrinking and growing
        var M_new = {};
        var totalShrink = 0;
        var totalGrow = 0;
        for (var c = 0; c < LAND_CATEGORIES.length; c++) {
            var cat = LAND_CATEGORIES[c];
            var rawNew = M_physical[cat] * (1.0 + desiredChange[cat]);
            // Enforce protected floor
            var floor = protect_vec[cat] * (M_initial ? M_initial[cat] : M_physical[cat]);
            rawNew = Math.max(rawNew, floor, 1.0); // hard min 1 ha
            M_new[cat] = rawNew;
            if (rawNew < M_physical[cat]) {
                totalShrink += M_physical[cat] - rawNew;
            } else {
                totalGrow += rawNew - M_physical[cat];
            }
        }

        // Conserve total land area: scale growth to match shrinkage
        if (totalGrow > 0 && totalShrink > 0) {
            var growScale = totalShrink / totalGrow;
            for (var c = 0; c < LAND_CATEGORIES.length; c++) {
                var cat = LAND_CATEGORIES[c];
                if (M_new[cat] > M_physical[cat]) {
                    var growth = M_new[cat] - M_physical[cat];
                    M_new[cat] = M_physical[cat] + growth * growScale;
                }
            }
        } else if (totalGrow <= 0 && totalShrink > 0) {
            // Everything wants to shrink — revert to no change
            return Object.assign({}, M_physical);
        }

        // Final safety: hard minimum 1 ha
        for (var c = 0; c < LAND_CATEGORIES.length; c++) {
            M_new[LAND_CATEGORIES[c]] = Math.max(M_new[LAND_CATEGORIES[c]], 1.0);
        }

        return M_new;
    }

    // Apply land conversion and update landParams in-place
    // Call after solving a year, using that year's rent_per_ha
    function applyLandConversion(landParams, rent_per_ha) {
        if (!landParams || !rent_per_ha || !landParams.epsilon_supply) return;
        var oldPhys = landParams.M_physical;
        var newPhys = reallocateLand(oldPhys, rent_per_ha, landParams.epsilon_supply, landParams.protect_land, landParams.M_physical_init);
        // Update M_vec proportionally: M̃_i(new) = M̃_i(old) × newPhys_i / oldPhys_i
        for (var c = 0; c < LAND_CATEGORIES.length; c++) {
            var cat = LAND_CATEGORIES[c];
            var ratio = newPhys[cat] / Math.max(oldPhys[cat], TINY);
            landParams.M_vec[cat] *= ratio;
            landParams.land_scale[cat] = landParams.M_vec[cat] / newPhys[cat];
        }
        landParams.M_physical = newPhys;
    }

    // ========================================
    // OUTPUT PREDICTION FUNCTIONS
    // ========================================

    // Production function: CES core Y_hat = A × cesTaskAgg(K̃, L̃, α, σ_K)
    // where K̃ = K/K₀, L̃ = L_eff/L_eff₀ (normalized by base-year values)
    // When σ_K ≈ 1, reduces to Cobb-Douglas Y_hat = A × K_Y^α × L_eff^(1-α)
    function productionFunction(A, K_Y, L_eff, alpha, sigma_K, K0_base, Leff0_base) {
        sigma_K = sigma_K || 1.0;
        if (Math.abs(sigma_K - 1.0) < 1e-10) {
            return A * Math.pow(K_Y, alpha) * Math.pow(L_eff, 1.0 - alpha);
        }
        // Normalize by base-year values so CES share = α at base year
        const K_norm = (K0_base > 0) ? K_Y / K0_base : K_Y;
        const L_norm = (Leff0_base > 0) ? L_eff / Leff0_base : L_eff;
        return A * cesKL(K_norm, L_norm, alpha, sigma_K);
    }

    // Full production function with optional sequential CES land layers
    // Y_hat → (land nests?) → Y_final
    function productionFunctionFull(A, K_Y, L_eff, alpha, landParams, sigma_K, K0_base, Leff0_base, trustParams) {
        let Y = productionFunction(A, K_Y, L_eff, alpha, sigma_K, K0_base, Leff0_base);
        if (trustParams && trustParams.active) {
            Y = ces2(trustParams.X_trust, Y, trustParams.s_trust, trustParams.sigma_trust);
        }
        if (landParams) {
            var result = sequentialLandCES(Y, landParams);
            Y = result.Y_final;
        }
        return Y;
    }

    // Calibrate TFP (A) from base year data
    // CES with normalization: A = Y / cesTaskAgg(K/K₀, L_eff/L_eff₀, α, σ_K)
    // At base year: K/K₀ = 1, L_eff/L_eff₀ = 1, so A = Y / CES(1,1) = Y
    // Cobb-Douglas: A = Y / (K_Y^α × L_eff^(1-α))
    function calibrateTFP(Y, K_Y, L_eff, alpha, sigma_K, K0_base, Leff0_base) {
        sigma_K = sigma_K || 1.0;
        if (Math.abs(sigma_K - 1.0) < 1e-10) {
            return Y / (Math.pow(K_Y, alpha) * Math.pow(L_eff, 1.0 - alpha));
        }
        const K_norm = (K0_base > 0) ? K_Y / K0_base : K_Y;
        const L_norm = (Leff0_base > 0) ? L_eff / Leff0_base : L_eff;
        return Y / cesKL(K_norm, L_norm, alpha, sigma_K);
    }

    // Solve for predicted output in one year using fixed-point iteration
    // Returns the equilibrium Y where production function is satisfied
    function solveYearWithPredictedOutput(row, params, landParams, A, Y_guess, trustParams, maxIter = 10, tol = 1e-3) {
        let Y = Y_guess;

        for (let iter = 0; iter < maxIter; iter++) {
            // Create row with current Y guess
            const rowWithY = { ...row, Y: Y };

            // Solve equilibrium given Y (H_trust solved endogenously inside)
            const result = solveMuOneYear(rowWithY, params, landParams, trustParams);

            // Get K_Y and L_eff from equilibrium
            const K_Y = result.K_Y;
            const L_eff = result.L_eff;

            // Use solved X_trust for production function check
            const trustParamsResolved = (trustParams && trustParams.active && result.X_trust > 0)
                ? Object.assign({}, trustParams, { X_trust: result.X_trust }) : trustParams;

            // Compute predicted Y from full production function (CES + trust + land)
            const Y_pred = productionFunctionFull(A, K_Y, L_eff, params.alpha, landParams, params.sigma_K, params.K0_base, params.Leff0_base, trustParamsResolved);

            // Check convergence
            const relError = Math.abs(Y_pred - Y) / Math.max(Y, TINY);
            if (relError < tol) {
                // Converged - return full result with predicted Y
                const finalRow = { ...row, Y: Y_pred };
                const finalResult = solveMuOneYear(finalRow, params, landParams, trustParams);
                finalResult.Y_predicted = Y_pred;
                finalResult.Y_forecast = row.Y;  // Original Y from spreadsheet
                return finalResult;
            }

            // Update Y with damping for stability
            Y = 0.5 * Y + 0.5 * Y_pred;
        }

        // Return last result even if not fully converged
        const finalRow = { ...row, Y: Y };
        const finalResult = solveMuOneYear(finalRow, params, landParams, trustParams);
        finalResult.Y_predicted = Y;
        finalResult.Y_forecast = row.Y;
        finalResult.Y_converged = false;
        return finalResult;
    }

    // Compute average wage: w̄ = w_c × ℓ_c + w_p × (1 - ℓ_c)
    function computeAverageWage(wc, wp, ell_c) {
        return wc * ell_c + wp * (1.0 - ell_c);
    }

    // Legacy labor supply function (used when distribution mode is off)
    function laborSupply(B, wbar, psi, workingAgePop) {
        const L_uncapped = B * Math.pow(Math.max(wbar, TINY), 1.0 / psi);
        return Math.min(L_uncapped, workingAgePop);
    }

    // Legacy calibration (used when distribution mode is off)
    function calibrateLaborSupplyB(L_0, wbar_0, psi) {
        return L_0 / Math.pow(Math.max(wbar_0, TINY), 1.0 / psi);
    }

    // ---- New LFP model: logistic baseline × UBI dampener ----

    // Logistic function on log(w_multiple), auto-calibrated so F(1) = lfp_target
    // F(x) = 1 / (1 + exp(-s * (ln(x) - shift)))
    // At x=1: ln(1)=0, so F(1) = 1/(1+exp(s*shift)) = lfp_target
    // => exp(s*shift) = 1/lfp_target - 1
    // => shift = ln(1/lfp_target - 1) / s   (negative when lfp_target > 0.5)
    function lfpBaselineCurve(w_multiple, lfp_target, logistic_s) {
        var shift = Math.log(1.0 / lfp_target - 1.0) / logistic_s;
        var z = logistic_s * (Math.log(Math.max(w_multiple, TINY)) - shift);
        return 1.0 / (1.0 + Math.exp(-z));
    }

    // UBI dampener: D(ratio) = exp(-k_ubi * ratio)
    // When ratio = UBI/wage = 1, D = exp(-k_ubi) ≈ 0.323 for k_ubi=1.13
    // So LFP = 0.62 * 0.323 ≈ 0.20
    function lfpUBIDampener(ubi_per_person, wbar, k_ubi) {
        if (ubi_per_person <= 0 || wbar <= 0) return 1.0;
        var ratio = ubi_per_person / wbar;
        return Math.exp(-k_ubi * ratio);
    }

    // Combined LFP: participation_rate = F(w_multiple) × D(UBI/wage)
    function computeLFP(wbar, wbar0, ubi_per_person, params) {
        var w_multiple = wbar / Math.max(wbar0, TINY);
        var p_base = lfpBaselineCurve(w_multiple, params.lfp_target, params.logistic_s);
        var dampener = lfpUBIDampener(ubi_per_person, wbar, params.k_ubi);
        return p_base * dampener;
    }

    // Compute UBI per person from equilibrium result (factored out for reuse)
    // Returns UBI per working-age person in the same units as wages (model $)
    // workingAgePop: working age population for this year
    function computeUBIPerPerson(year, eqResult, params, workingAgePop) {
        var d_ubi_start = params.dist_ubi_start_year || 9999;
        if (year < d_ubi_start) return 0;
        var d_tau_k = params.dist_tau_k || 0;
        var d_tau_AI = params.dist_tau_AI || 0;
        var d_tau_R = params.dist_tau_R || 0;
        var d_ubi_share_us = params.dist_ubi_share_us || 0;
        var T_total = d_tau_k * eqResult.r * eqResult.K_Y +
                      d_tau_AI * eqResult.qc * eqResult.AI_cog +
                      d_tau_R * eqResult.qr * eqResult.R_phys;
        return T_total * d_ubi_share_us / Math.max(workingAgePop, 1);
    }

    // Solve for predicted output WITH endogenous labor supply
    // Outer loop: iterate on Y until production function holds
    // Inner loop: iterate on L until labor supply converges
    // Uses new LFP model when params.wbar0 is set, else legacy B×w̄^(1/ψ)
    function solveYearWithPredictedOutputAndEndogenousLabor(row, params, landParams, A, B, workingAgePop, Y_guess, trustParams, maxOuterIter, maxInnerIter, tol) {
        maxOuterIter = maxOuterIter || 10;
        maxInnerIter = maxInnerIter || 8;
        tol = tol || 1e-3;
        var useLFP = params.wbar0 != null;
        var damp = params.labor_damp || 0.5;
        var Y = Y_guess;

        for (var outerIter = 0; outerIter < maxOuterIter; outerIter++) {
            var L = row.H_data || workingAgePop * 0.6;

            for (var innerIter = 0; innerIter < maxInnerIter; innerIter++) {
                var rowWithYL = Object.assign({}, row, { Y: Y, H_cog: L, H_phys: L });
                var result = solveMuOneYear(rowWithYL, params, landParams, trustParams);
                var wbar = computeAverageWage(result.wc, result.wp, result.ell_c);
                var H_trust_iter = result.H_trust || 0;

                var L_new;
                if (useLFP) {
                    // Merge row data (AI_cog, R_phys) with equilibrium result (r, qc, qr, K_Y)
                    var merged = Object.assign({}, row, result);
                    var ubi = computeUBIPerPerson(row.year, merged, params, workingAgePop);
                    // Use best available wage for LFP: trust wage if higher than main economy
                    var trust_w = result.trust_wage || 0;
                    var effective_wage = Math.max(wbar, trust_w);
                    var lfp = computeLFP(effective_wage, params.wbar0, ubi, params);
                    L_new = Math.min(lfp * workingAgePop, workingAgePop);
                } else {
                    L_new = laborSupply(B, wbar, params.psi, workingAgePop);
                }

                if (Math.abs(L_new - L) / Math.max(L, TINY) < tol) {
                    L = L_new;
                    break;
                }
                L = (1 - damp) * L + damp * L_new;
            }

            var rowWithYL2 = Object.assign({}, row, { Y: Y, H_cog: L, H_phys: L });
            var result2 = solveMuOneYear(rowWithYL2, params, landParams, trustParams);
            var K_Y = result2.K_Y;
            var L_eff = result2.L_eff;
            var trustParamsResolved2 = (trustParams && trustParams.active && result2.X_trust > 0)
                ? Object.assign({}, trustParams, { X_trust: result2.X_trust }) : trustParams;
            var Y_pred = productionFunctionFull(A, K_Y, L_eff, params.alpha, landParams, params.sigma_K, params.K0_base, params.Leff0_base, trustParamsResolved2);

            var relError = Math.abs(Y_pred - Y) / Math.max(Y, TINY);
            if (relError < tol) {
                var finalRow = Object.assign({}, row, { Y: Y_pred, H_cog: L, H_phys: L });
                var finalResult = solveMuOneYear(finalRow, params, landParams, trustParams);
                finalResult.Y_predicted = Y_pred;
                finalResult.Y_forecast = row.Y;
                finalResult.L_endogenous = L;
                finalResult.wbar = computeAverageWage(finalResult.wc, finalResult.wp, finalResult.ell_c);
                finalResult.effective_wage = Math.max(finalResult.wbar, finalResult.trust_wage || 0);
                finalResult.participation_rate = L / workingAgePop;
                if (useLFP) {
                    var mergedFinal = Object.assign({}, row, finalResult);
                    finalResult.ubi_per_person = computeUBIPerPerson(row.year, mergedFinal, params, workingAgePop);
                }
                return finalResult;
            }
            Y = 0.5 * Y + 0.5 * Y_pred;
        }

        var finalRow2 = Object.assign({}, row, { Y: Y, H_cog: L, H_phys: L });
        var finalResult2 = solveMuOneYear(finalRow2, params, landParams, trustParams);
        finalResult2.Y_predicted = Y;
        finalResult2.Y_forecast = row.Y;
        finalResult2.L_endogenous = L;
        finalResult2.wbar = computeAverageWage(finalResult2.wc, finalResult2.wp, finalResult2.ell_c);
        finalResult2.effective_wage = Math.max(finalResult2.wbar, finalResult2.trust_wage || 0);
        finalResult2.participation_rate = L / workingAgePop;
        finalResult2.Y_converged = false;
        if (useLFP) {
            var mergedFinal2 = Object.assign({}, row, finalResult2);
            finalResult2.ubi_per_person = computeUBIPerPerson(row.year, mergedFinal2, params, workingAgePop);
        }
        return finalResult2;
    }

    // ========================================
    // INCOME DISTRIBUTION FUNCTIONS
    // ========================================

    // Standard normal quantile (inverse CDF) — Peter Acklam's rational approximation
    function normInv(p) {
        if (p <= 0) return -Infinity;
        if (p >= 1) return Infinity;
        if (Math.abs(p - 0.5) < 1e-15) return 0;

        var a = [-3.969683028665376e1, 2.209460984245205e2, -2.759285104469687e2,
                  1.383577518672690e2, -3.066479806614716e1, 2.506628277459239e0];
        var b = [-5.447609879822406e1, 1.615858368580409e2, -1.556989798598866e2,
                  6.680131188771972e1, -1.328068155288572e1];
        var c = [-7.784894002430293e-3, -3.223964580411365e-1, -2.400758277161838e0,
                 -2.549732539343734e0, 4.374664141464968e0, 2.938163982698783e0];
        var d = [7.784695709041462e-3, 3.224671290700398e-1, 2.445134137142996e0,
                 3.754408661907416e0];

        var p_low = 0.02425;
        var p_high = 1 - p_low;
        var q, r;

        if (p < p_low) {
            q = Math.sqrt(-2 * Math.log(p));
            return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) /
                   ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        } else if (p <= p_high) {
            q = p - 0.5;
            r = q * q;
            return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q /
                   (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
        } else {
            q = Math.sqrt(-2 * Math.log(1 - p));
            return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) /
                    ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
    }

    // Number of distribution households: 99 percentiles + 10 ultra-wealthy buckets = 109
    var N_HOUSEHOLDS = 109;

    // Percentile boundaries for 109 households: [0, 0.01, ..., 0.99, 0.991, ..., 1.0]
    var PERCENTILE_BOUNDARIES = (function() {
        var b = [0];
        for (var i = 1; i <= 99; i++) b.push(i / 100);
        for (var i = 1; i <= 10; i++) b.push((990 + i) / 1000);
        return b; // length 110, giving 109 intervals
    })();

    // Interpolate Lorenz curve from empirical CDF breakpoints
    // cdfBreaks: [L1, L25, L50, L75, L90, L99, L999]
    // Piecewise-linear Lorenz interpolation from 9 knot points
    function lorenzInterp(p, cdfBreaks) {
        var knots_p = [0, 0.01, 0.25, 0.50, 0.75, 0.90, 0.99, 0.999, 1.0];
        var knots_L = [0, cdfBreaks[0], cdfBreaks[1], cdfBreaks[2], cdfBreaks[3], cdfBreaks[4], cdfBreaks[5], cdfBreaks[6], 1.0];
        if (p <= 0) return 0;
        if (p >= 1) return 1;
        for (var i = 0; i < knots_p.length - 1; i++) {
            if (p <= knots_p[i + 1]) {
                var t = (p - knots_p[i]) / (knots_p[i + 1] - knots_p[i]);
                return knots_L[i] + t * (knots_L[i + 1] - knots_L[i]);
            }
        }
        return 1;
    }

    // Generate ownership shares from empirical CDF breakpoints for 109 households
    // cdfBreaks: [L(0.50), L(0.90), L(0.99)]
    function ownershipFromCDF(cdfBreaks, n) {
        n = n || N_HOUSEHOLDS;
        var shares = [];
        for (var h = 0; h < n; h++) {
            var p_lo = PERCENTILE_BOUNDARIES[h];
            var p_hi = PERCENTILE_BOUNDARIES[h + 1];
            var L_lo = lorenzInterp(p_lo, cdfBreaks);
            var L_hi = lorenzInterp(p_hi, cdfBreaks);
            shares.push(Math.max(L_hi - L_lo, 0));
        }
        return shares;
    }

    // Generate wage/skill distribution from CDF breakpoints
    // For wages, the CDF gives income shares. We convert to per-household skill levels.
    // Approach: the slope of the Lorenz curve at percentile p gives the relative wage.
    // skill(p) = dL/dp at percentile midpoint, normalized so mean = 1.
    function wageDistFromCDF(cdfBreaks, n) {
        n = n || N_HOUSEHOLDS;
        var skills = [];
        var sumWeighted = 0;
        for (var h = 0; h < n; h++) {
            var p_lo = PERCENTILE_BOUNDARIES[h];
            var p_hi = PERCENTILE_BOUNDARIES[h + 1];
            var dp = p_hi - p_lo;
            var L_lo = lorenzInterp(p_lo, cdfBreaks);
            var L_hi = lorenzInterp(p_hi, cdfBreaks);
            // Slope = dL/dp = relative income per unit of population
            var slope = (L_hi - L_lo) / dp;
            skills.push(slope);
            sumWeighted += slope * dp; // weighted by population fraction
        }
        // sumWeighted should be ~1.0 (integral of dL/dp over [0,1])
        // Normalize so population-weighted mean = 1
        for (var h = 0; h < n; h++) skills[h] /= sumWeighted;
        return skills;
    }

    // Build 109 households with ownership shares and wage skills
    function initializeHouseholds(params) {
        var n = N_HOUSEHOLDS;
        var own_K = ownershipFromCDF(params.cdf_capital, n);
        var own_AI = ownershipFromCDF(params.cdf_ai, n);
        var own_R = ownershipFromCDF(params.cdf_robot, n);
        var own_Land = ownershipFromCDF(params.cdf_land, n);
        var wageSkills = wageDistFromCDF(params.cdf_wage, n);

        // Build percentile labels: 1-99, then 99.1, 99.2, ..., 100
        var labels = [];
        for (var i = 1; i <= 99; i++) labels.push(i);
        for (var i = 1; i <= 10; i++) labels.push(99 + i / 10);

        var households = [];
        for (var h = 0; h < n; h++) {
            households.push({
                percentile: labels[h],
                skill: wageSkills[h],
                own_K: own_K[h],
                own_AI: own_AI[h],
                own_R: own_R[h],
                own_Land: own_Land[h]
            });
        }
        return households;
    }

    // Solve one year with endogenous labor supply (spreadsheet mode)
    // Uses new LFP model when params.wbar0 is set (distribution mode):
    //   LFP = F(w_multiple) × D(UBI/wage)
    // Falls back to legacy L = B × w̄^(1/ψ) otherwise.
    function solveWithEndogenousLabor(row, params, landParams, B, workingAgePop, trustParams, maxIter, tol) {
        maxIter = maxIter || 10;
        tol = tol || 1e-3;
        var useLFP = params.wbar0 != null;
        var damp = params.labor_damp || 0.5;

        var L = row.H_data || workingAgePop * 0.6;

        for (var iter = 0; iter < maxIter; iter++) {
            var rowWithL = Object.assign({}, row, { H_cog: L, H_phys: L });
            var result = solveMuOneYear(rowWithL, params, landParams, trustParams);
            var wbar = computeAverageWage(result.wc, result.wp, result.ell_c);
            var H_trust_iter = result.H_trust || 0;

            var L_new;
            if (useLFP) {
                // Merge row data (AI_cog, R_phys) with equilibrium result (r, qc, qr, K_Y)
                var merged = Object.assign({}, row, result);
                var ubi = computeUBIPerPerson(row.year, merged, params, workingAgePop);
                // Use best available wage for LFP: trust wage if higher than main economy
                var trust_w = result.trust_wage || 0;
                var effective_wage = Math.max(wbar, trust_w);
                var lfp = computeLFP(effective_wage, params.wbar0, ubi, params);
                L_new = Math.min(lfp * workingAgePop, workingAgePop);
            } else {
                L_new = laborSupply(B, wbar, params.psi, workingAgePop);
            }

            if (Math.abs(L_new - L) / Math.max(L, TINY) < tol) {
                L = L_new;
                break;
            }
            L = (1 - damp) * L + damp * L_new;
        }

        // Final solve with converged L
        var finalRow = Object.assign({}, row, { H_cog: L, H_phys: L });
        var finalResult = solveMuOneYear(finalRow, params, landParams, trustParams);
        finalResult.L_endogenous = L;
        finalResult.wbar = computeAverageWage(finalResult.wc, finalResult.wp, finalResult.ell_c);
        finalResult.effective_wage = Math.max(finalResult.wbar, finalResult.trust_wage || 0);
        finalResult.participation_rate = L / workingAgePop;
        if (useLFP) {
            var mergedFinal = Object.assign({}, row, finalResult);
            finalResult.ubi_per_person = computeUBIPerPerson(row.year, mergedFinal, params, workingAgePop);
        }
        return finalResult;
    }

    // Monotone PCHIP interpolator (shape-preserving cubic Hermite)
    // Returns object with evalAt(x) method for smooth interpolation
    function makePchip(xs, ys) {
        var n = xs.length;
        if (n < 2) return { evalAt: function() { return 0; } };
        var h = [], d = [];
        for (var i = 0; i < n - 1; i++) {
            h.push(xs[i + 1] - xs[i]);
            if (h[i] <= 0) h[i] = 1e-12;
            d.push((ys[i + 1] - ys[i]) / h[i]);
        }
        var m = new Array(n);
        m[0] = d[0];
        m[n - 1] = d[n - 2];
        for (var i = 1; i < n - 1; i++) {
            if (d[i - 1] === 0 || d[i] === 0 || (d[i - 1] > 0) !== (d[i] > 0)) {
                m[i] = 0;
            } else {
                var w1 = 2 * h[i] + h[i - 1];
                var w2 = h[i] + 2 * h[i - 1];
                m[i] = (w1 + w2) / (w1 / d[i - 1] + w2 / d[i]);
            }
        }
        function findInterval(x) {
            if (x <= xs[0]) return 0;
            if (x >= xs[n - 1]) return n - 2;
            var lo = 0, hi = n - 2;
            while (lo <= hi) {
                var mid = (lo + hi) >> 1;
                if (xs[mid] <= x && x <= xs[mid + 1]) return mid;
                if (x < xs[mid]) hi = mid - 1; else lo = mid + 1;
            }
            return lo;
        }
        return {
            evalAt: function(x) {
                if (x <= xs[0]) return ys[0];
                if (x >= xs[n - 1]) return ys[n - 1];
                var i = findInterval(x);
                var t = (x - xs[i]) / h[i];
                var t2 = t * t, t3 = t2 * t;
                var h00 = 2 * t3 - 3 * t2 + 1;
                var h10 = t3 - 2 * t2 + t;
                var h01 = -2 * t3 + 3 * t2;
                var h11 = t3 - t2;
                return h00 * ys[i] + h10 * h[i] * m[i] + h01 * ys[i + 1] + h11 * h[i] * m[i + 1];
            },
            evalDeriv: function(x) {
                var i = findInterval(x);
                if (x <= xs[0]) return m[0];
                if (x >= xs[n - 1]) return m[n - 1];
                var t = (x - xs[i]) / h[i];
                var t2 = t * t;
                var dh00 = 6 * t2 - 6 * t;
                var dh10 = 3 * t2 - 4 * t + 1;
                var dh01 = -6 * t2 + 6 * t;
                var dh11 = 3 * t2 - 2 * t;
                var dydt = dh00 * ys[i] + dh10 * h[i] * m[i] + dh01 * ys[i + 1] + dh11 * h[i] * m[i + 1];
                return dydt / h[i];
            }
        };
    }

    // Build a smooth PCHIP Lorenz curve from CDF breakpoints (cached)
    var _lorenzCache = {};
    function getLorenzPchip(cdfBreaks) {
        var key = cdfBreaks.join(',');
        if (!_lorenzCache[key]) {
            var knots_p = [0, 0.01, 0.25, 0.50, 0.75, 0.90, 0.99, 0.999, 1.0];
            var knots_L = [0, cdfBreaks[0], cdfBreaks[1], cdfBreaks[2], cdfBreaks[3], cdfBreaks[4], cdfBreaks[5], cdfBreaks[6], 1.0];
            _lorenzCache[key] = makePchip(knots_p, knots_L);
        }
        return _lorenzCache[key];
    }

    // Build a PCHIP interpolator in log-space from income multiplier anchors.
    // For zero/near-zero multipliers, clamp to a small floor so log works.
    // Returns a function: pct (0-100) → multiplier at that percentile.
    function buildMultiplierCurve(mult) {
        var pcts = mult.pcts;
        var vals = mult.vals;
        var FLOOR = 1e-6;
        var logVals = vals.map(function(v) { return Math.log(Math.max(v, FLOOR)); });
        var pchip = makePchip(pcts, logVals);
        return function(pct) {
            return Math.max(0, Math.exp(pchip.evalAt(pct)));
        };
    }

    // Compute smooth income/net-worth distribution at dense percentiles
    // Uses income multiplier curves (PCHIP in log-space) — guaranteed smooth.
    // Returns { income: [{x,y}...], networth: [{x,y}...], components: {wage:[{x,y}...], ...} }
    function computeSmoothDistribution(r, params) {
        // Build multiplier curves from params
        var mw = buildMultiplierCurve(params.mult_wage);
        var mk = buildMultiplierCurve(params.mult_capital);
        var ma = buildMultiplierCurve(params.mult_ai);
        var mr = buildMultiplierCurve(params.mult_robot);
        var ml = buildMultiplierCurve(params.mult_land);

        // Total factor incomes
        var total_wage = r.wc * (r.H_cog_allocated || r.Hc) + r.wp * (r.H_phys_allocated || r.Hp);
        var total_cap = r.r * r.K_Y;
        var total_ai = r.qc * r.AI_cog;
        var total_robot = r.qr * r.R_phys;
        var total_land = 0;
        if (r.revenue_per_category) {
            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++)
                total_land += r.revenue_per_category[LAND_CATEGORIES[ci]] || 0;
        }
        var total_trust = r.trust_income || 0;

        var isUS = typeof isUSMode === 'function' && isUSMode();
        var N_hh = isUS ? 131e6 : 2e9;

        // Taxes and UBI (per household — UBI goes to everyone equally)
        var d_tau_k = params.dist_tau_k || 0, d_tau_AI = params.dist_tau_AI || 0, d_tau_R = params.dist_tau_R || 0;
        var d_ubi_start = params.dist_ubi_start_year || 9999;
        var ubi = 0;
        var net_cap, net_ai, net_robot;
        if (r.year >= d_ubi_start) {
            net_cap = total_cap * (1 - d_tau_k);
            net_ai = total_ai * (1 - d_tau_AI);
            net_robot = total_robot * (1 - d_tau_R);
            // UBI: tax revenue distributed to all households equally
            var ubi_share = isUS ? (params.dist_ubi_share_us || 0) : (params.dist_ubi_share_world || 0);
            var T_total = d_tau_k * (r.r || 0) * (r.K_Y || 0) +
                          d_tau_AI * (r.qc || 0) * (r.AI_cog || 0) +
                          d_tau_R * (r.qr || 0) * (r.R_phys || 0);
            ubi = T_total * ubi_share / N_hh;
        } else { net_cap = total_cap; net_ai = total_ai; net_robot = total_robot; }

        // Asset values for net worth
        var K_total = r.K || 0, K_AI = r.K_C || 0, K_R = r.K_R || 0;
        var land_val = 0;
        if (r.physical_land && r.rent_per_ha) {
            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                var cat = LAND_CATEGORIES[ci];
                land_val += (r.rent_per_ha[cat] || 0) * (r.physical_land[cat] || 0) / 0.04;
            }
        }

        // Mean per-household values (multiplier × mean = income at percentile)
        var mean_wage = total_wage / N_hh;
        var mean_trust = total_trust / N_hh;
        var mean_cap = net_cap / N_hh;
        var mean_ai = net_ai / N_hh;
        var mean_robot = net_robot / N_hh;
        var mean_land = total_land / N_hh;
        var mean_K = K_total / N_hh;
        var mean_KAI = K_AI / N_hh;
        var mean_KR = K_R / N_hh;
        var mean_landval = land_val / N_hh;

        var income = [], networth = [];
        var comp_wage = [], comp_cap = [], comp_ai = [], comp_robot = [], comp_land = [];
        var comp_trust = [], comp_ubi = [];

        // Dense sample from p5 to p99.9
        for (var pct = 5; pct <= 99.9 + 1e-9; pct += 0.5) {
            // Multipliers at this percentile
            var fw = mw(pct);
            var fk = mk(pct);
            var fa = ma(pct);
            var fr = mr(pct);
            var fl = ml(pct);

            // Per-household income = multiplier × mean
            var w_h = fw * mean_wage;
            var trust_h = fw * mean_trust;  // trust distributed like wages
            var k_h = fk * mean_cap;
            var a_h = fa * mean_ai;
            var r_h = fr * mean_robot;
            var l_h = fl * mean_land;
            var tot = w_h + trust_h + k_h + a_h + r_h + l_h + ubi;

            income.push({ x: pct, y: tot });
            comp_wage.push({ x: pct, y: w_h });
            comp_cap.push({ x: pct, y: k_h });
            comp_ai.push({ x: pct, y: a_h });
            comp_robot.push({ x: pct, y: r_h });
            comp_land.push({ x: pct, y: l_h });
            comp_trust.push({ x: pct, y: trust_h });
            comp_ubi.push({ x: pct, y: ubi });

            // Net worth: use capital multiplier for K, ai for K_AI, robot for K_R, land for land
            var nw = fk * mean_K + fa * mean_KAI + fr * mean_KR + fl * mean_landval;
            networth.push({ x: pct, y: nw });
        }

        return {
            income: income, networth: networth,
            components: { wage: comp_wage, capital: comp_cap, ai: comp_ai,
                          robot: comp_robot, land: comp_land, trust: comp_trust, ubi: comp_ubi }
        };
    }

    // Weighted Gini coefficient: values[i] = per-household value, weights[i] = population fraction
    // Uses the standard formula: G = (Σ_i Σ_j w_i w_j |y_i - y_j|) / (2 μ)
    // Optimized: sort by value, then use cumulative sums
    function computeWeightedGini(values, weights) {
        var n = values.length;
        // Build sorted index array
        var idx = [];
        for (var i = 0; i < n; i++) idx.push(i);
        idx.sort(function(a, b) { return values[a] - values[b]; });

        // Compute weighted mean
        var totalWeight = 0, weightedSum = 0;
        for (var i = 0; i < n; i++) {
            totalWeight += weights[i];
            weightedSum += values[i] * weights[i];
        }
        var mean = weightedSum / Math.max(totalWeight, TINY);
        if (mean <= 0) return 0;

        // Cumulative weight approach: G = 1 - 2 * Σ(w_i * S_i) / weightedSum
        // where S_i = cumulative income share up to and including i
        var cumWeight = 0, cumIncome = 0, sum = 0;
        for (var k = 0; k < n; k++) {
            var i = idx[k];
            var w = weights[i] / totalWeight;
            var y = values[i] * weights[i] / weightedSum;
            cumWeight += w;
            cumIncome += y;
            sum += w * (cumIncome - y / 2); // trapezoidal
        }
        return Math.max(0, Math.min(1, 1 - 2 * sum));
    }

    // Compute income distribution for all years
    // All incomes and net worths are PER HOUSEHOLD (not per-percentile-bucket aggregate)
    // Each of the bottom 99 buckets represents 1% of pop; top 10 each represent 0.1%
    function computeIncomeDistribution(results, households, params) {
        var n = households.length;
        var distribution = [];

        // Population weight per bucket: how many real households each bucket represents
        // Bottom 99: each = 1% of pop. Top 10: each = 0.1% of pop.
        // We want per-household income, so divide bucket aggregates by (pop_weight × total_households)
        // Equivalent: divide ownership share by pop fraction to get per-household share
        // pop_fraction[h]: fraction of total population in bucket h
        var pop_fraction = [];
        for (var h = 0; h < 99; h++) pop_fraction.push(0.01);  // 1% each
        for (var h = 0; h < 10; h++) pop_fraction.push(0.001); // 0.1% each

        // Number of actual households (US ~131M, or proportional to population)
        var isUS = typeof isUSMode === 'function' && isUSMode();
        var total_real_households = isUS ? 131e6 : 2e9;

        // Base-year median wage (household skill × avg wage at base year)
        // Median household is at percentile 50 → index 49
        var baseResult = results[0];
        var L_base = baseResult.L_endogenous || baseResult.H_cog || 1;
        var baseAvgWage = (baseResult.wc * (baseResult.H_cog_allocated || baseResult.Hc) +
                           baseResult.wp * (baseResult.H_phys_allocated || baseResult.Hp)) / Math.max(L_base, 1);
        var median_wage_2025 = households[49].skill * baseAvgWage;

        // Population for UBI: US ~330M, World ex-China ~6.5B
        var us_pop = 330e6;
        var world_ex_china_pop = 6.5e9;

        for (var t = 0; t < results.length; t++) {
            var r = results[t];
            var year = r.year;

            // Total factor incomes
            var total_wage_income = r.wc * (r.H_cog_allocated || r.Hc) + r.wp * (r.H_phys_allocated || r.Hp);
            var total_capital_income = r.r * r.K_Y;
            var total_ai_income = r.qc * r.AI_cog;
            var total_robot_income = r.qr * r.R_phys;
            var total_land_income = 0;
            if (r.revenue_per_category) {
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                    total_land_income += r.revenue_per_category[LAND_CATEGORIES[ci]] || 0;
                }
            }
            var total_trust_income = r.trust_income || 0;

            // Tax revenue and UBI (uses shared helper)
            var d_tau_k = params.dist_tau_k || 0;
            var d_tau_AI = params.dist_tau_AI || 0;
            var d_tau_R = params.dist_tau_R || 0;
            var d_ubi_start = params.dist_ubi_start_year || 9999;
            var workingAgePop = r.WorkingAgePop || 270e6;
            var ubi_per_person = computeUBIPerPerson(year, r, params, workingAgePop);

            // Use the participation rate already computed by the solver (includes smoothing)
            var part_rate = r.participation_rate || 0.62;

            // Determine which households work: top (part_rate × n) by skill
            var sorted_indices = [];
            for (var h = 0; h < n; h++) sorted_indices.push(h);
            sorted_indices.sort(function(a, b) { return households[b].skill - households[a].skill; });
            var n_working = Math.round(part_rate * n);
            var working = new Array(n);
            for (var h = 0; h < n; h++) working[h] = false;
            for (var w = 0; w < Math.min(n_working, n); w++) working[sorted_indices[w]] = true;

            // Sum of skill × pop_fraction for working households (weighted by population they represent)
            var total_working_skill_weight = 0;
            for (var h = 0; h < n; h++) {
                if (working[h]) total_working_skill_weight += households[h].skill * pop_fraction[h];
            }

            // Net factor incomes (after taxes that fund UBI)
            var net_wage_income = total_wage_income; // wages not taxed
            var net_capital_income, net_ai_income, net_robot_income;
            if (year >= d_ubi_start) {
                net_capital_income = total_capital_income * (1 - d_tau_k);
                net_ai_income = total_ai_income * (1 - d_tau_AI);
                net_robot_income = total_robot_income * (1 - d_tau_R);
            } else {
                net_capital_income = total_capital_income;
                net_ai_income = total_ai_income;
                net_robot_income = total_robot_income;
            }

            // Asset values for net worth
            var K_total = r.K || 0;
            var K_AI_value = r.K_C || 0;
            var K_R_value = r.K_R || 0;
            var land_value = 0;
            if (r.physical_land && r.rent_per_ha) {
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                    var cat = LAND_CATEGORIES[ci];
                    land_value += (r.rent_per_ha[cat] || 0) * (r.physical_land[cat] || 0) / 0.04;
                }
            }

            var yearHouseholds = [];
            for (var h = 0; h < n; h++) {
                var hh = households[h];
                var pf = pop_fraction[h];
                var n_real = pf * total_real_households; // real households in this bucket

                // Wage: bucket gets (skill × pf / total_working_skill_weight) share of total wages
                // Then divide by n_real to get per-household
                var wage_bucket = working[h] ? (hh.skill * pf / Math.max(total_working_skill_weight, TINY)) * net_wage_income : 0;
                var wage_h = wage_bucket / n_real;

                // Asset income: ownership share gives bucket's total, divide by n_real
                var cap_h = (hh.own_K * net_capital_income) / n_real;
                var ai_h = (hh.own_AI * net_ai_income) / n_real;
                var robot_h = (hh.own_R * net_robot_income) / n_real;
                var land_h = (hh.own_Land * total_land_income) / n_real;
                // Trusted labor income: distributed like wages (proportional to skill among workers)
                var trust_bucket = working[h] ? (hh.skill * pf / Math.max(total_working_skill_weight, TINY)) * total_trust_income : 0;
                var trust_h = trust_bucket / n_real;
                var ubi_h = ubi_per_person; // already per person
                var total_h = wage_h + cap_h + ai_h + robot_h + land_h + trust_h + ubi_h;

                var networth_h = (hh.own_K * K_total + hh.own_AI * K_AI_value +
                                  hh.own_R * K_R_value + hh.own_Land * land_value) / n_real;

                yearHouseholds.push({
                    percentile: hh.percentile,
                    wage: wage_h,
                    capital: cap_h,
                    ai: ai_h,
                    robot: robot_h,
                    land: land_h,
                    trust: trust_h,
                    ubi: ubi_h,
                    total: total_h,
                    networth: networth_h
                });
            }

            // Compute Gini coefficients for this year
            var incomeValues = [], wealthValues = [];
            for (var h = 0; h < n; h++) {
                incomeValues.push(Math.max(yearHouseholds[h].total, 0));
                wealthValues.push(Math.max(yearHouseholds[h].networth, 0));
            }
            var gini_income = computeWeightedGini(incomeValues, pop_fraction);
            var gini_wealth = computeWeightedGini(wealthValues, pop_fraction);

            distribution.push({
                year: year,
                households: yearHouseholds,
                participation_rate: part_rate,
                ubi_per_person: ubi_per_person,
                gini_income: gini_income,
                gini_wealth: gini_wealth
            });
        }

        return distribution;
    }

    // CES for K-L nest with simple α weights: Q = [α × x^ρ + (1-α) × y^ρ]^(1/ρ)
    // At equal inputs: share_x = α exactly (unlike cesTaskAgg which uses α^(1/σ))
    // Used only for the capital-labor production function nest
    function cesKL(x, y, alpha, sigma) {
        x = Math.max(x, TINY);
        y = Math.max(y, TINY);
        alpha = Math.max(TINY, Math.min(alpha, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return Math.pow(x, alpha) * Math.pow(y, 1.0 - alpha);
        }

        const rho = (sigma - 1.0) / sigma;
        const term1 = alpha * Math.pow(x, rho);
        const term2 = (1.0 - alpha) * Math.pow(y, rho);
        return Math.pow(term1 + term2, 1.0 / rho);
    }

    // Derivative of cesKL wrt first input x (weight α)
    // dQ/dx = Q^(1-ρ) × α × x^(ρ-1)
    function dCesKL_dx(Q, x, alpha, sigma) {
        x = Math.max(x, TINY);
        Q = Math.max(Q, TINY);

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return alpha * Q / x;
        }

        const rho = (sigma - 1.0) / sigma;
        return Math.pow(Q, 1.0 - rho) * alpha * Math.pow(x, rho - 1.0);
    }

    // Derivative of cesKL wrt second input y (weight 1-α)
    // dQ/dy = Q^(1-ρ) × (1-α) × y^(ρ-1)
    function dCesKL_dy(Q, y, alpha, sigma) {
        y = Math.max(y, TINY);
        Q = Math.max(Q, TINY);

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return (1.0 - alpha) * Q / y;
        }

        const rho = (sigma - 1.0) / sigma;
        return Math.pow(Q, 1.0 - rho) * (1.0 - alpha) * Math.pow(y, rho - 1.0);
    }

    // CES task aggregator (used for labor nests — uses μ^(1/σ) weights)
    function cesTaskAgg(x, y, mu, sigma) {
        x = Math.max(x, TINY);
        y = Math.max(y, TINY);
        mu = Math.max(TINY, Math.min(mu, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            // Cobb-Douglas limit
            return Math.pow(x, mu) * Math.pow(y, 1.0 - mu);
        }

        const rho = (sigma - 1.0) / sigma;
        const term1 = Math.pow(mu, 1.0 / sigma) * Math.pow(x, rho);
        const term2 = Math.pow(1.0 - mu, 1.0 / sigma) * Math.pow(y, rho);
        return Math.pow(term1 + term2, 1.0 / rho);
    }

    // Derivative wrt first input (weight mu)
    function dQdxFirst(Q, x, mu, sigma) {
        x = Math.max(x, TINY);
        Q = Math.max(Q, TINY);
        mu = Math.max(TINY, Math.min(mu, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return mu * Q / x;
        }

        const rho = (sigma - 1.0) / sigma;
        return Math.pow(Q, 1.0 - rho) * Math.pow(mu, 1.0 / sigma) * Math.pow(x, rho - 1.0);
    }

    // Derivative wrt second input (weight 1-mu)
    function dQdySecond(Q, y, mu, sigma) {
        y = Math.max(y, TINY);
        Q = Math.max(Q, TINY);
        mu = Math.max(TINY, Math.min(mu, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return (1.0 - mu) * Q / y;
        }

        const rho = (sigma - 1.0) / sigma;
        return Math.pow(Q, 1.0 - rho) * Math.pow(1.0 - mu, 1.0 / sigma) * Math.pow(y, rho - 1.0);
    }

    // Bisection root finder
    function bisectRoot(func, lo, hi, maxIter = 30, tol = 1e-6) {
        let flo = func(lo);
        let fhi = func(hi);

        if (Math.abs(flo) < tol) return lo;
        if (Math.abs(fhi) < tol) return hi;

        if (flo * fhi > 0) {
            return Math.abs(flo) < Math.abs(fhi) ? lo : hi;
        }

        let a = lo, b = hi, fa = flo, fb = fhi;

        for (let i = 0; i < maxIter; i++) {
            const m = 0.5 * (a + b);
            const fm = func(m);

            if (Math.abs(fm) < tol || (b - a) < 1e-14) {
                return m;
            }

            if (fa * fm <= 0) {
                b = m;
                fb = fm;
            } else {
                a = m;
                fa = fm;
            }
        }

        return 0.5 * (a + b);
    }

    // Solve for interest rate from capital market clearing
    // With CES: K_Y found by bisection where A × dQ/dK(K_Y, L_eff) = r
    // With Cobb-Douglas: K_Y = alpha*Y/r
    function solveROneT(Kt, Yt, q_c, q_p, LAI, LR, params, L_eff, A_tfp) {
        const { alpha, delta_K, delta_C, delta_R, tau_k, tau_AI, tau_R } = params;
        const sigma_K = params.sigma_K || 1.0;
        const K0_base = params.K0_base || 0;
        const Leff0_base = params.Leff0_base || 0;
        const one_minus_tau_k = 1.0 - tau_k;

        // Helper: find K_Y given r (CES requires bisection)
        function KY_from_r(r) {
            if (Math.abs(sigma_K - 1.0) < 1e-10) {
                return alpha * Yt / r;
            }
            // Bisect: find K where A_tfp * dQ/dK_norm / K₀ = r
            // (chain rule: dY/dK = A × dQ/d(K/K₀) / K₀)
            const K0 = (K0_base > 0) ? K0_base : 1.0;
            const L_norm = (Leff0_base > 0) ? L_eff / Leff0_base : L_eff;
            return bisectRoot(function(Ktest) {
                var K_norm = Ktest / K0;
                var Q = cesKL(K_norm, L_norm, alpha, sigma_K);
                return A_tfp * dCesKL_dx(Q, K_norm, alpha, sigma_K) / K0 - r;
            }, TINY, Kt * 10, 120, 1e-12);
        }

        // Minimum r to keep denominators positive
        const r_min_C = (delta_K - delta_C) / one_minus_tau_k + 1e-8;
        const r_min_R = (delta_K - delta_R) / one_minus_tau_k + 1e-8;
        const r_min = Math.max(1e-8, r_min_C, r_min_R);

        function RHS(r) {
            const termY = KY_from_r(r);
            let termC = 0.0;
            if (LAI > 0 && isFinite(q_c)) {
                const denom_C = one_minus_tau_k * r - delta_K + delta_C;
                if (denom_C > TINY) {
                    termC = (1.0 - tau_AI) * q_c * LAI / denom_C;
                }
            }
            let termR = 0.0;
            if (LR > 0 && isFinite(q_p)) {
                const denom_R = one_minus_tau_k * r - delta_K + delta_R;
                if (denom_R > TINY) {
                    termR = (1.0 - tau_R) * q_p * LR / denom_R;
                }
            }
            return termY + termC + termR;
        }

        function H(r) {
            return RHS(r) - Kt;
        }

        // Find upper bound where H(r_hi) < 0
        let r_hi = Math.max(1.0, r_min * 10);
        for (let i = 0; i < 80; i++) {
            if (H(r_hi) < 0) break;
            r_hi *= 2.0;
        }

        // Bisection
        let a = r_min, b = r_hi;
        let fa = H(a), fb = H(b);

        if (!isFinite(fa)) {
            a = r_min * 1.01;
            fa = H(a);
        }

        for (let i = 0; i < 150; i++) {
            const m = 0.5 * (a + b);
            const fm = H(m);
            if (Math.abs(fm) < 1e-12) {
                a = b = m;
                break;
            }
            if (fa * fm > 0) {
                a = m;
                fa = fm;
            } else {
                b = m;
                fb = fm;
            }
        }
        return 0.5 * (a + b);
    }

    // Compute capital allocations given r
    // With CES: K_Y found by bisection where A × dQ/dK(K_Y, L_eff) = r
    // With Cobb-Douglas: K_Y = alpha*Y/r
    function computeCapitalAllocations(Kt, Yt, r, q_c, q_p, LAI, LR, params, L_eff, A_tfp) {
        const { alpha, delta_K, delta_C, delta_R, tau_k, tau_AI, tau_R } = params;
        const sigma_K = params.sigma_K || 1.0;
        const K0_base = params.K0_base || 0;
        const Leff0_base = params.Leff0_base || 0;
        const one_minus_tau_k = 1.0 - tau_k;

        // Find K_Y given r (CES requires bisection)
        let K_Y;
        if (Math.abs(sigma_K - 1.0) < 1e-10) {
            K_Y = alpha * Yt / r;
        } else {
            const K0 = (K0_base > 0) ? K0_base : 1.0;
            const L_norm = (Leff0_base > 0) ? L_eff / Leff0_base : L_eff;
            K_Y = bisectRoot(function(Ktest) {
                var K_norm = Ktest / K0;
                var Q = cesKL(K_norm, L_norm, alpha, sigma_K);
                return A_tfp * dCesKL_dx(Q, K_norm, alpha, sigma_K) / K0 - r;
            }, TINY, Kt * 10, 120, 1e-12);
        }
        let K_C = 0.0;
        if (LAI > 0 && isFinite(q_c)) {
            const denom_C = one_minus_tau_k * r - delta_K + delta_C;
            if (denom_C > TINY) {
                K_C = (1.0 - tau_AI) * q_c * LAI / denom_C;
            }
        }
        let K_R = 0.0;
        if (LR > 0 && isFinite(q_p)) {
            const denom_R = one_minus_tau_k * r - delta_K + delta_R;
            if (denom_R > TINY) {
                K_R = (1.0 - tau_R) * q_p * LR / denom_R;
            }
        }
        return {
            K_Y,
            K_C,
            K_R,
            share_KY: K_Y / Kt,
            share_KC: K_C / Kt,
            share_KR: K_R / Kt
        };
    }

    // Human split given wage ratio z = wc/wp
    // L_c/L_p = kappa * z^omega => ell_c = kappa*z^omega / (kappa*z^omega + 1)
    function humanSplit(L, z, kappa, omega) {
        z = Math.max(z, TINY);
        const x = kappa * Math.pow(z, omega);
        const ell = x / (x + 1.0);
        const Hc = ell * L;
        const Hp = (1.0 - ell) * L;
        return { Hc: Math.max(Hc, TINY), Hp: Math.max(Hp, TINY), ell_c: ell };
    }

    // Prices given mu and wage ratio z (which determines Hc, Hp via human split)
    // PY is the shadow price of final output (used in land mode)
    function pricesGivenMuAndZ(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, z, params, PY = 1.0) {
        const { alpha, theta, eps, sig_c, sig_p, kappa, omega } = params;
        const sigma_K = params.sigma_K || 1.0;

        // Compute human split from wage ratio
        const split = humanSplit(L, z, kappa, omega);
        const Hc = split.Hc;
        const Hp = split.Hp;

        // Nests
        const L_cog = cesTaskAgg(Hc, AIc, mu_h_c, sig_c);
        const L_phys = cesTaskAgg(Hp, Rp, mu_h_p, sig_p);
        const L_eff = cesTaskAgg(L_cog, L_phys, theta, eps);

        // Infer A and marginal products using CES or Cobb-Douglas
        // For CES: normalize K and L_eff by base-year values so share = α at base year
        const K0_base = params.K0_base || 0;
        const Leff0_base = params.Leff0_base || 0;
        let A, r_raw, mp_Leff;
        if (Math.abs(sigma_K - 1.0) < 1e-10) {
            // Cobb-Douglas
            A = Y / (Math.pow(K, alpha) * Math.pow(L_eff, 1.0 - alpha));
            r_raw = alpha * Y / K;
            mp_Leff = (1.0 - alpha) * Y / L_eff;
        } else {
            // CES with normalized inputs (using cesKL with simple α weights)
            const K_norm = (K0_base > 0) ? K / K0_base : K;
            const L_norm = (Leff0_base > 0) ? L_eff / Leff0_base : L_eff;
            const Q = cesKL(K_norm, L_norm, alpha, sigma_K);
            A = Y / Q;
            // Chain rule: dY/dK = A × dQ/d(K/K₀) × (1/K₀)
            r_raw = A * dCesKL_dx(Q, K_norm, alpha, sigma_K) / ((K0_base > 0) ? K0_base : 1.0);
            mp_Leff = A * dCesKL_dy(Q, L_norm, alpha, sigma_K) / ((Leff0_base > 0) ? Leff0_base : 1.0);
        }
        const r = r_raw;

        // Chain rule derivatives
        const dLeff_dLcog = dQdxFirst(L_eff, L_cog, theta, eps);
        const dLeff_dLphys = dQdySecond(L_eff, L_phys, theta, eps);

        const dLcog_dHc = dQdxFirst(L_cog, Hc, mu_h_c, sig_c);
        const dLcog_dAIc = dQdySecond(L_cog, AIc, mu_h_c, sig_c);

        const dLphys_dHp = dQdxFirst(L_phys, Hp, mu_h_p, sig_p);
        const dLphys_dRp = dQdySecond(L_phys, Rp, mu_h_p, sig_p);

        // Scale wages by PY (shadow price of final output)
        const wc = PY * mp_Leff * dLeff_dLcog * dLcog_dHc;
        const qc = PY * mp_Leff * dLeff_dLcog * dLcog_dAIc;
        const wp = PY * mp_Leff * dLeff_dLphys * dLphys_dHp;
        const qr = PY * mp_Leff * dLeff_dLphys * dLphys_dRp;

        const profit = Y - (r * K + wc * Hc + wp * Hp + qc * AIc + qr * Rp);

        return { A, r, wc, wp, qc, qr, Hc, Hp, ell_c: split.ell_c, profit, L_eff, L_cog, L_phys };
    }

    // Inner solver: fixed-point iteration for z = wc/wp
    // When trustParams is provided, co-iterates on H_trust to equalize trust_wage and wbar.
    // When landParams is provided, recomputes PY each step (needed when H_trust varies).
    function solveZForMu(Y, K, L_total, AIc, Rp, mu_h_c, mu_h_p, params, z0, damp, maxIter, tol, PY_fixed, trustParams, landParams, bar_auto_c, bar_auto_p) {
        z0 = z0 || 1.0;
        damp = damp || 0.6;
        maxIter = maxIter || 30;
        tol = tol || 1e-4;
        PY_fixed = PY_fixed || 1.0;
        bar_auto_c = bar_auto_c || 0;
        bar_auto_p = bar_auto_p || 0;

        var trustActive = trustParams && trustParams.active;
        var trustAnchored = trustActive && trustParams.anchor_H_trust;
        var H_trust = trustActive ? (trustParams.prev_H_trust || trustParams.H_trust_seed || L_total * 0.01) : 0;
        var trust_wage = 0;
        var trust_income = 0;
        var X_trust = 0;
        var PY_trust = 1.0;
        var PY_land = 1.0;
        var trustDamp = 0.3;

        let logz = Math.log(z0);

        for (let i = 0; i < maxIter; i++) {
            // Current L after trust subtraction
            var L = trustActive ? Math.max(L_total - H_trust, TINY) : L_total;

            // Compute PY from trust + land layers (recomputed each step when H_trust varies)
            var PY;
            if (trustActive || landParams) {
                PY_trust = 1.0;
                PY_land = 1.0;
                if (trustActive && H_trust > TINY) {
                    X_trust = trustParams.C_trust * H_trust;
                    var Y_at = ces2(X_trust, Y, trustParams.s_trust, trustParams.sigma_trust);
                    PY_trust = ces2_dZ_dXagg(Y_at, Y, trustParams.s_trust, trustParams.sigma_trust);
                    var trust_rent = ces2_dZ_dXland(Y_at, X_trust, trustParams.s_trust, trustParams.sigma_trust);
                    trust_income = trust_rent * X_trust;
                    trust_wage = trust_rent * trustParams.C_trust;
                } else {
                    trust_wage = 0;
                    trust_income = 0;
                    X_trust = 0;
                }
                if (landParams) {
                    var Y_for_land = trustActive && H_trust > TINY ? Y_at : Y;
                    var lr = sequentialLandCES(Y_for_land, landParams);
                    PY_land = sequentialLandPY(lr, landParams);
                }
                PY = PY_trust * PY_land;
            } else {
                PY = PY_fixed;
            }

            const z = Math.exp(logz);
            const out = pricesGivenMuAndZ(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, z, params, PY);

            // z-iteration uses unpinned wages
            const z_hat = out.wc / out.wp;
            const logz_hat = Math.log(z_hat);

            // Co-iterate on H_trust: adjust toward wage equalization
            var z_converged = Math.abs(logz_hat - logz) < tol;
            var trust_converged = true;

            if (trustActive) {
                if (trustAnchored) {
                    // Start year: fix H_trust at calibrated value so wage matches parameter
                    trust_converged = true;
                } else {
                    // For trust equilibrium, use no-arbitrage-pinned wages so trust
                    // sees the correct wbar when automation caps wc and/or wp
                    var wc_eff = (bar_auto_c >= 1.0 - 1e-6 && out.wc > out.qc) ? out.qc : out.wc;
                    var wp_eff = (bar_auto_p >= 1.0 - 1e-6 && out.wp > out.qr) ? out.qr : out.wp;
                    var wbar = computeAverageWage(wc_eff, wp_eff, out.ell_c);
                    var tw = trust_wage * PY_land;  // trust wage in final-output units

                    if (wbar > TINY && tw > TINY) {
                        // Log-space update: prevents explosive jumps when tw >> wbar
                        var ratio = tw / wbar;
                        var log_H = Math.log(Math.max(H_trust, 1));
                        var log_H_target = log_H + trustParams.sigma_trust * Math.log(ratio);
                        var H_trust_new = Math.exp(log_H_target);
                        H_trust_new = Math.max(1, Math.min(H_trust_new, L_total - 1));
                        trust_converged = Math.abs(Math.log(Math.max(H_trust_new, 1)) - log_H) < tol;
                        // Damped update in log-space
                        H_trust = Math.exp((1.0 - trustDamp) * log_H + trustDamp * Math.log(Math.max(H_trust_new, 1)));
                        H_trust = Math.max(1, Math.min(H_trust, L_total - 1));
                    } else if (wbar <= TINY && tw > TINY) {
                        // Main economy wages collapsed, everyone goes to trust
                        H_trust = L_total - 1;
                        trust_converged = false;
                    } else {
                        // Trust wage is zero — no one goes
                        H_trust = 0;
                        trust_converged = true;
                    }
                }
            }

            if (z_converged && trust_converged) {
                out.z = Math.exp(logz_hat);
                out.H_trust = H_trust;
                out.trust_wage_raw = trust_wage;
                out.trust_income_raw = trust_income;
                out.X_trust = X_trust;
                out.PY_trust = PY_trust;
                out.PY_land = PY_land;
                return out;
            }

            logz = (1.0 - damp) * logz + damp * logz_hat;
        }

        // Return last result even if not fully converged
        var L_final = trustActive ? Math.max(L_total - H_trust, TINY) : L_total;
        var PY_final = (trustActive || landParams) ? PY_trust * PY_land : PY_fixed;
        const z = Math.exp(logz);
        const out = pricesGivenMuAndZ(Y, K, L_final, AIc, Rp, mu_h_c, mu_h_p, z, params, PY_final);
        out.z = z;
        out.z_converged = false;
        out.H_trust = H_trust;
        out.trust_wage_raw = trust_wage;
        out.trust_income_raw = trust_income;
        out.X_trust = X_trust;
        out.PY_trust = PY_trust;
        out.PY_land = PY_land;
        return out;
    }

    // Main solver for one year
    // landParams: { sigma_L, s_L, M, zeta } - if provided, enables land mode
    // trustParams: { s_trust, sigma_trust, C_trust, active } - trusted labor sector
    // H_trust is solved endogenously inside solveZForMu via co-iteration with z.
    function solveMuOneYear(row, params, landParams = null, trustParams = null) {
        // Gate taxes on start year: zero tax rates before ubi_start_year
        var ubi_start = params.ubi_start_year || 9999;
        var year = row.year || 0;
        if (year < ubi_start) {
            params = Object.assign({}, params, { tau_k: 0, tau_AI: 0, tau_R: 0 });
        }

        const { Y, K, H_cog, AI_cog, R_phys, bar_auto_c, bar_auto_p } = row;
        const trustActive = trustParams && trustParams.active;
        const AIc = AI_cog;
        const Rp = R_phys;

        // bar_auto is max automatable share => min human share = 1 - bar_auto
        const mu_h_c_min = Math.max(1e-9, Math.min(1.0 - 1e-9, 1.0 - Math.max(0, Math.min(bar_auto_c, 1.0 - 1e-12))));
        const mu_h_p_min = Math.max(1e-9, Math.min(1.0 - 1e-9, 1.0 - Math.max(0, Math.min(bar_auto_p, 1.0 - 1e-12))));

        // Start at frontier (automate as much as possible)
        let mu_h_c = mu_h_c_min;
        let mu_h_p = mu_h_p_min;

        // When trust is active, solveZForMu co-iterates on H_trust and recomputes
        // PY from trust+land layers each step. When trust is NOT active, pre-compute
        // PY from land once (it doesn't change during z-iteration) for efficiency.
        var PY_pre = 1.0;
        var _tp = null;
        var _lp = null;
        if (trustActive) {
            // Trust active: pass both into solveZForMu so PY is recomputed each step
            _tp = trustParams;
            _lp = landParams;
        } else if (landParams) {
            // Land only: pre-compute PY_land once
            var _lr = sequentialLandCES(Y, landParams);
            PY_pre = sequentialLandPY(_lr, landParams);
        }
        let out = solveZForMu(Y, K, H_cog, AIc, Rp, mu_h_c, mu_h_p, params, 1.0, 0.6, 30, 1e-4, PY_pre, _tp, _lp, bar_auto_c, bar_auto_p);

        const need_c = out.wc < out.qc;
        const need_p = out.wp < out.qr;

        // Coordinate bisection on mu's
        let mu_c_cur = mu_h_c;
        let mu_p_cur = mu_h_p;

        for (let iter = 0; iter < 30; iter++) {
            const prev_c = mu_c_cur;
            const prev_p = mu_p_cur;

            if (need_c) {
                const f = (mu) => {
                    const o = solveZForMu(Y, K, H_cog, AIc, Rp, mu, mu_p_cur, params, 1.0, 0.6, 30, 1e-4, PY_pre, _tp, _lp, bar_auto_c, bar_auto_p);
                    return Math.log(o.wc / o.qc);
                };
                mu_c_cur = bisectRoot(f, mu_h_c_min, 1.0 - 1e-9);
            }

            if (need_p) {
                const g = (mu) => {
                    const o = solveZForMu(Y, K, H_cog, AIc, Rp, mu_c_cur, mu, params, 1.0, 0.6, 30, 1e-4, PY_pre, _tp, _lp, bar_auto_c, bar_auto_p);
                    return Math.log(o.wp / o.qr);
                };
                mu_p_cur = bisectRoot(g, mu_h_p_min, 1.0 - 1e-9);
            }

            if (Math.max(Math.abs(mu_c_cur - prev_c), Math.abs(mu_p_cur - prev_p)) < 1e-4) {
                break;
            }
        }

        // Final solve with converged mu values
        const final = solveZForMu(Y, K, H_cog, AIc, Rp, mu_c_cur, mu_p_cur, params, 1.0, 0.6, 30, 1e-4, PY_pre, _tp, _lp, bar_auto_c, bar_auto_p);

        // No-arbitrage at full automation
        if (bar_auto_c >= 1.0 - 1e-6 && final.wc > final.qc) {
            final.wc = final.qc;
        }
        if (bar_auto_p >= 1.0 - 1e-6 && final.wp > final.qr) {
            final.wp = final.qr;
        }

        // Extract trust and land outputs from the converged solver
        const H_trust = final.H_trust || 0;
        const L = Math.max(H_cog - H_trust, TINY);
        const trust_wage_raw = final.trust_wage_raw || 0;
        const trust_income_raw = final.trust_income_raw || 0;
        const X_trust_val = final.X_trust || 0;
        const PY_trust = final.PY_trust || 1.0;
        // When trust is not active, PY_land was pre-computed as PY_pre (not passed into solveZForMu)
        const PY_land = trustActive ? (final.PY_land || 1.0) : (landParams ? PY_pre : 1.0);
        const PY = PY_trust * PY_land;

        // Compute Y_final from trust + land layers (for income shares)
        let Y_after_trust = Y;
        if (trustActive && H_trust > TINY) {
            Y_after_trust = ces2(X_trust_val, Y, trustParams.s_trust, trustParams.sigma_trust);
        }
        let Y_final = Y_after_trust;
        let v_per_category = {};
        let revenue_per_category = {};
        if (landParams) {
            var landResult = sequentialLandCES(Y_after_trust, landParams);
            Y_final = landResult.Y_final;
            var v_scaled = sequentialLandRents(landResult, landParams);
            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                var cat = LAND_CATEGORIES[ci];
                v_per_category[cat] = v_scaled[cat];
                revenue_per_category[cat] = v_scaled[cat] * landParams.M_vec[cat];
            }
        }

        // Solve for interest rate from capital market clearing
        const r = solveROneT(K, Y, final.qc, final.qr, AIc, Rp, params, final.L_eff, final.A);
        const capAlloc = computeCapitalAllocations(K, Y, r, final.qc, final.qr, AIc, Rp, params, final.L_eff, final.A);

        // Factor income shares
        const alpha = params.alpha;
        const sigma_K_share = params.sigma_K || 1.0;
        const K0_base_share = params.K0_base || 0;
        const Leff0_base_share = params.Leff0_base || 0;
        let ces_capital_share;
        if (Math.abs(sigma_K_share - 1.0) < 1e-10) {
            ces_capital_share = alpha;
        } else {
            const rho = (sigma_K_share - 1.0) / sigma_K_share;
            const K_n = (K0_base_share > 0) ? K / K0_base_share : K;
            const L_n = (Leff0_base_share > 0) ? final.L_eff / Leff0_base_share : final.L_eff;
            const termK = alpha * Math.pow(K_n, rho);
            const termL = (1.0 - alpha) * Math.pow(L_n, rho);
            ces_capital_share = termK / (termK + termL);
        }
        const ces_labor_share = 1.0 - ces_capital_share;
        const human_cog_val = final.wc * final.Hc;
        const human_phys_val = final.wp * final.Hp;
        const ai_val = final.qc * AIc;
        const robot_val = final.qr * Rp;
        const total_labor_val = human_cog_val + human_phys_val + ai_val + robot_val;

        let land_income = 0;
        if (landParams) {
            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                land_income += revenue_per_category[LAND_CATEGORIES[ci]] || 0;
            }
        }

        const { tau_k, tau_AI, tau_R } = params;
        const T_capital = tau_k * r * capAlloc.K_Y;
        const T_AI = tau_AI * final.qc * AIc;
        const T_robot = tau_R * final.qr * Rp;

        const wage_per_worker = (human_cog_val + human_phys_val) / L;
        const WAP = row.WorkingAgePop || L;
        const T_capital_per_worker = T_capital / WAP;
        const T_AI_per_worker = T_AI / WAP;
        const T_robot_per_worker = T_robot / WAP;

        const total_income = Y_final;
        const yhat_to_yfinal = ((landParams || trustActive) && Y_final > TINY) ? PY * Y / Y_final : 1.0;
        const cap_share_final = ces_capital_share * yhat_to_yfinal;
        const lab_share_final = ces_labor_share * yhat_to_yfinal;
        const labor_frac = (total_labor_val > TINY) ? 1.0 / total_labor_val : 0;

        const trust_income_final = trust_income_raw * PY_land;
        const trust_income_share = trustActive ? trust_income_final / Math.max(Y_final, TINY) : 0;

        const result = {
            ...final,
            r,
            ...capAlloc,
            mu_h_c: mu_c_cur,
            mu_h_p: mu_p_cur,
            mu_h_c_min,
            mu_h_p_min,
            H_cog_allocated: final.Hc,
            H_phys_allocated: final.Hp,
            regime_c: need_c ? "endogenous" : "frontier",
            regime_p: need_p ? "endogenous" : "frontier",
            capital_share: cap_share_final,
            human_cog_share: lab_share_final * human_cog_val * labor_frac,
            human_phys_share: lab_share_final * human_phys_val * labor_frac,
            ai_share: lab_share_final * ai_val * labor_frac,
            robot_share: lab_share_final * robot_val * labor_frac,
            trust_income: trust_income_final,
            trust_income_share: trust_income_share,
            trust_wage: trust_wage_raw * PY_land,
            H_trust: H_trust,
            X_trust: X_trust_val,
            wage_per_worker,
            T_capital_per_worker,
            T_AI_per_worker,
            T_robot_per_worker,
            T_total_per_worker: T_capital_per_worker + T_AI_per_worker + T_robot_per_worker
        };

        if (trustActive || landParams) {
            result.Y_final = Y_final;
            result.PY = PY;
        }

        if (landParams) {
            result.land_income_share = land_income / total_income;
            result.v_per_category = v_per_category;
            result.revenue_per_category = revenue_per_category;
            result.rent_per_ha = {};
            result.effective_land = {};
            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                var cat = LAND_CATEGORIES[ci];
                result.rent_per_ha[cat] = (v_per_category[cat] || 0) * (landParams.land_scale[cat] || 1.0);
                result.effective_land[cat] = (landParams.C_vec[cat] || 1.0) * (landParams.M_physical[cat] || 0);
            }
            result.physical_land = Object.assign({}, landParams.M_physical);
        }

        return result;
    }

    // ========================================
    // CSV Parsing
    // ========================================

    function parseCell(x) {
        if (x === null || x === undefined || x === '') return NaN;

        const s = String(x).trim();
        if (s === '' || s.toLowerCase() === 'nan') return NaN;

        // Percentage
        if (s.endsWith('%')) {
            return parseFloat(s.slice(0, -1)) / 100.0;
        }

        // Remove $ and commas
        let s2 = s.replace(/\$/g, '').replace(/,/g, '').trim();

        // Match number with optional suffix
        const match = s2.match(/^([-+]?\d*\.?\d+)([KMBT])?$/i);
        if (match) {
            let num = parseFloat(match[1]);
            const suf = match[2];
            if (suf) {
                const mult = { 'K': 1e3, 'M': 1e6, 'B': 1e9, 'T': 1e12 };
                num *= mult[suf.toUpperCase()];
            }
            return num;
        }

        return parseFloat(s2);
    }

    function parseCSV(csvText) {
        const result = Papa.parse(csvText, {
            header: false,
            skipEmptyLines: false
        });

        const rows = result.data;
        if (rows.length === 0) {
            throw new Error("Empty CSV file");
        }

        // First row should be headers with years
        const headerRow = rows[0];
        const yearCols = [];
        const years = [];

        for (let i = 0; i < headerRow.length; i++) {
            const val = String(headerRow[i]).trim();
            if (/^\d{4}$/.test(val)) {
                yearCols.push(i);
                years.push(parseInt(val));
            }
        }

        if (years.length === 0) {
            throw new Error("No year columns found in the header row");
        }

        // Build label to series map
        const labelToSeries = {};
        for (let r = 1; r < rows.length; r++) {
            const row = rows[r];
            if (!row || !row[0]) continue;

            const label = String(row[0]).trim();
            if (!label) continue;

            const series = yearCols.map(i => parseCell(row[i]));
            labelToSeries[label] = series;
        }

        // Column name mappings (new template names -> internal names)
        // Support both old format and new simplified format
        const columnMappings = {
            // Human labor
            "Human Labor Force": "H",
            "US Human Labor Force": "H",
            // Working age population (for endogenous labor supply)
            "Human Working Age Population": "WorkingAgePop",
            // AI cognitive
            "AI Cognitive": "AI_cog",
            "US AI cognitive": "AI_cog",
            // Robotic physical
            "Robotic Physical": "R_phys",
            "US RObotic physical": "R_phys",
            // Output
            "Output": "Y",
            "US Economy": "Y",
            // Capital
            "Capital": "K",
            "US 'Normal' Capital": "K",
            // Cognitive automation frontier
            "Cognitive Automation Frontier": "bar_auto_c",
            "% of cognitive jobs that can be automated": "bar_auto_c",
            // Physical automation frontier
            "Physical Automation Frontier": "bar_auto_p",
            "% of physical jobs that can be automated": "bar_auto_p"
        };

        // Map labels to internal names
        const mappedSeries = {};
        for (const [label, series] of Object.entries(labelToSeries)) {
            if (columnMappings[label]) {
                mappedSeries[columnMappings[label]] = series;
            }
        }

        // Check required fields
        const requiredFields = ["H", "AI_cog", "R_phys", "Y", "K", "bar_auto_c", "bar_auto_p"];
        const missingFields = requiredFields.filter(f => !mappedSeries[f]);

        if (missingFields.length > 0) {
            throw new Error(`Missing required rows. Please ensure your CSV has: Human Labor Force, AI Cognitive, Robotic Physical, Output, Capital, Cognitive Automation Frontier, Physical Automation Frontier`);
        }

        // Build data array
        const data = [];
        for (let i = 0; i < years.length; i++) {
            data.push({
                year: years[i],
                Y: mappedSeries["Y"][i],
                K: mappedSeries["K"][i],
                H_cog: mappedSeries["H"][i],
                H_phys: mappedSeries["H"][i],
                H_data: mappedSeries["H"][i],  // Original labor force from data (for calibration)
                WorkingAgePop: mappedSeries["WorkingAgePop"] ? mappedSeries["WorkingAgePop"][i] : null,
                AI_cog: mappedSeries["AI_cog"][i],
                R_phys: mappedSeries["R_phys"][i],
                bar_auto_c: mappedSeries["bar_auto_c"][i],
                bar_auto_p: mappedSeries["bar_auto_p"][i]
            });
        }

        return data;
    }

    // ========================================
    // Editable Scenario Table
    // ========================================

    function buildScenarioTable(rowData, years, shareRows) {
        const wrapper = document.getElementById('scenarioTableWrapper');
        var allRows = rowData.slice();
        if (shareRows) {
            allRows = allRows.concat(shareRows);
        }

        // Pre-compute derived row initial values from editable rows
        var editableValues = {};
        allRows.forEach(function(row) {
            if (!row.derived && row.values) {
                editableValues[row.label] = row.values.map(function(v) { return parseCell(v); });
            }
        });

        let html = '<table id="scenarioTable"><thead><tr><th>Variable</th>';
        for (const y of years) {
            html += '<th>' + y + '</th>';
        }
        html += '</tr></thead><tbody>';

        for (let r = 0; r < allRows.length; r++) {
            const row = allRows[r];
            var isDerived = !!row.derived;
            var isBold = !!row.bold;
            var labelStyle = isBold ? ' style="font-weight:700;"' : '';
            var rowStyle = isDerived ? ' style="background:#f0f0f0;"' : '';
            html += '<tr data-row-label="' + row.label + '"' + rowStyle + '>';
            html += '<td' + labelStyle + '>' + row.label + '</td>';

            if (isDerived) {
                var computed = row.compute ? row.compute(editableValues) : null;
                for (let c = 0; c < years.length; c++) {
                    var displayVal = (computed && computed[c] != null) ? formatForDisplay(computed[c], '') : '—';
                    html += '<td' + labelStyle + '><span class="derived-cell" data-row="' + r + '" data-col="' + c + '">' + displayVal + '</span></td>';
                }
            } else {
                for (let c = 0; c < years.length; c++) {
                    html += '<td' + labelStyle + '><input type="text" value="' + row.values[c] + '" data-row="' + r + '" data-col="' + c + '"' + (isBold ? ' style="font-weight:700;"' : '') + '></td>';
                }
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        wrapper.innerHTML = html;

        // Wire up live recalculation of derived rows on any input change
        var table = document.getElementById('scenarioTable');
        table.addEventListener('input', function() {
            recalcDerivedRows(allRows, years);
        });
    }

    function recalcDerivedRows(allRows, years) {
        var table = document.getElementById('scenarioTable');
        if (!table) return;

        // Read current editable values from the table
        var editableValues = {};
        var trs = table.querySelectorAll('tbody tr');
        trs.forEach(function(tr) {
            var label = tr.getAttribute('data-row-label');
            var matchRow = allRows.find(function(r) { return r.label === label; });
            if (matchRow && !matchRow.derived) {
                var inputs = tr.querySelectorAll('input');
                editableValues[label] = Array.from(inputs).map(function(inp) { return parseCell(inp.value); });
            }
        });

        // Update derived rows
        trs.forEach(function(tr) {
            var label = tr.getAttribute('data-row-label');
            var matchRow = allRows.find(function(r) { return r.label === label; });
            if (matchRow && matchRow.derived && matchRow.compute) {
                var computed = matchRow.compute(editableValues);
                var spans = tr.querySelectorAll('.derived-cell');
                spans.forEach(function(span, c) {
                    span.textContent = (computed && computed[c] != null) ? formatForDisplay(computed[c], '') : '—';
                });
            }
        });
    }

    function readTableData() {
        const table = document.getElementById('scenarioTable');
        if (!table) throw new Error("Scenario table not found");

        const rows = table.querySelectorAll('tbody tr');
        const years = TEMPLATE_YEARS;

        // Read all table rows into a label->series map
        const allLabels = [
            "AI Copies", "Human-equivs per AI Copy",
            "Robots", "Human-equivs per Robot",
            "Cognitive Automation Frontier", "Physical Automation Frontier",
            "US Share of Compute", "US Share of Robots"
        ];
        const tableSeries = {};
        rows.forEach(function(tr) {
            const label = tr.getAttribute('data-row-label');
            if (allLabels.indexOf(label) === -1) return;
            const inputs = tr.querySelectorAll('input');
            tableSeries[label] = Array.from(inputs).map(function(inp) { return parseCell(inp.value); });
        });

        // Mark invalid cells
        var hasInvalid = false;
        rows.forEach(function(tr) {
            const label = tr.getAttribute('data-row-label');
            if (allLabels.indexOf(label) === -1) return;
            const inputs = tr.querySelectorAll('input');
            inputs.forEach(function(inp) {
                var val = parseCell(inp.value);
                if (isNaN(val)) {
                    inp.classList.add('invalid');
                    hasInvalid = true;
                } else {
                    inp.classList.remove('invalid');
                }
            });
        });
        if (hasInvalid) {
            throw new Error("Invalid value(s) in input rows. Check highlighted cells.");
        }

        // Compute AI_cog = AI Copies × Human-equivs per AI Copy
        // Compute R_phys = Robots × Human-equivs per Robot
        var aiCopies = tableSeries["AI Copies"];
        var equivsPerAI = tableSeries["Human-equivs per AI Copy"];
        var robots = tableSeries["Robots"];
        var equivsPerRobot = tableSeries["Human-equivs per Robot"];

        if (!aiCopies || !equivsPerAI || !robots || !equivsPerRobot) {
            throw new Error("Missing component rows in the scenario table");
        }

        // In US mode, apply shares to quantities
        var usMode = isUSMode();
        if (usMode && tableSeries["US Share of Compute"] && tableSeries["US Share of Robots"]) {
            var computeShare = tableSeries["US Share of Compute"];
            var robotShare = tableSeries["US Share of Robots"];
            aiCopies = aiCopies.map(function(v, i) { return v * computeShare[i]; });
            robots = robots.map(function(v, i) { return v * robotShare[i]; });
        }

        var AI_cog = aiCopies.map(function(v, i) { return v * equivsPerAI[i]; });
        var R_phys = robots.map(function(v, i) { return v * equivsPerRobot[i]; });

        // Select background defaults based on mode
        var bgDefaults = usMode ? BACKGROUND_DEFAULTS_US : BACKGROUND_DEFAULTS_GLOBAL;
        var bgMappings = {
            "Human Labor Force": "H",
            "Human Working Age Population": "WorkingAgePop",
            "Output": "Y",
            "Capital": "K"
        };
        var mappedSeries = {};
        for (var label in bgMappings) {
            if (bgDefaults[label]) {
                mappedSeries[bgMappings[label]] = bgDefaults[label].map(function(v) { return parseCell(v); });
            }
        }

        // Override base-year values from the editable inputs
        var baseY = parseCell(document.getElementById('base_Y').value);
        var baseL = parseCell(document.getElementById('base_L').value);
        var baseWAP = parseCell(document.getElementById('base_WAP').value);
        if (!isNaN(baseY)) mappedSeries["Y"][0] = baseY;
        if (!isNaN(baseL)) mappedSeries["H"][0] = baseL;
        if (!isNaN(baseWAP) && mappedSeries["WorkingAgePop"]) mappedSeries["WorkingAgePop"][0] = baseWAP;

        // Build data array (identical to parseCSV output)
        var data = [];
        for (var i = 0; i < years.length; i++) {
            data.push({
                year: years[i],
                Y: mappedSeries["Y"][i],
                K: mappedSeries["K"][i],
                H_cog: mappedSeries["H"][i],
                H_phys: mappedSeries["H"][i],
                H_data: mappedSeries["H"][i],
                WorkingAgePop: mappedSeries["WorkingAgePop"] ? mappedSeries["WorkingAgePop"][i] : null,
                AI_cog: AI_cog[i],
                R_phys: R_phys[i],
                bar_auto_c: tableSeries["Cognitive Automation Frontier"][i],
                bar_auto_p: tableSeries["Physical Automation Frontier"][i],
                equivs_per_ai: equivsPerAI[i],
                equivs_per_robot: equivsPerRobot[i],
                h100e_per_ai_copy: H100E_PER_AI_COPY[i]
            });
        }

        return data;
    }

    function formatForDisplay(value, type) {
        if (value === null || isNaN(value)) return '';

        // Percentage fields
        if (type === 'bar_auto_c' || type === 'bar_auto_p') {
            return Math.round(value * 100) + '%';
        }

        // Numeric fields with suffix
        var abs = Math.abs(value);
        if (abs >= 1e12) return (value / 1e12).toFixed(1).replace(/\.0$/, '') + 'T';
        if (abs >= 1e9)  return (value / 1e9).toFixed(1).replace(/\.0$/, '') + 'B';
        if (abs >= 1e6)  return (value / 1e6).toFixed(1).replace(/\.0$/, '') + 'M';
        if (abs >= 1e3)  return (value / 1e3).toFixed(1).replace(/\.0$/, '') + 'K';
        if (abs >= 1)    return value.toFixed(1).replace(/\.0$/, '');
        if (abs >= 0.01) return value.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
        if (abs > 0)     return value.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
        return '0';
    }

    function populateTableFromLoadedData(data) {
        // Populate frontier rows from uploaded CSV data
        // Component rows (AI Copies, etc.) are left as-is since CSV has aggregate totals
        const labelToDataKey = {
            "Cognitive Automation Frontier": { key: "bar_auto_c", type: "bar_auto_c" },
            "Physical Automation Frontier": { key: "bar_auto_p", type: "bar_auto_p" }
        };

        const table = document.getElementById('scenarioTable');
        const rows = table.querySelectorAll('tbody tr');

        rows.forEach(function(tr) {
            const label = tr.getAttribute('data-row-label');
            const mapping = labelToDataKey[label];
            if (!mapping) return;

            const inputs = tr.querySelectorAll('input');
            for (let i = 0; i < inputs.length && i < data.length; i++) {
                const val = data[i][mapping.key];
                inputs[i].value = formatForDisplay(val, mapping.type);
                inputs[i].classList.remove('invalid');
            }
        });
    }

    // ========================================
    // Charting
    // ========================================

    let wagesChart = null;
    let rentalCostChart = null;
    let muChart = null;
    let ellChart = null;
    let capitalChart = null;
    let interestChart = null;
    let factorIncomeChart = null;
    let techChart = null;
    let laborChart = null;
    let wageIncomeChart = null;
    let ubiTransferChart = null;
    let outputChart = null;
    let landRentChart = null;
    let landUseShareChart = null;
    let landIncomeShareChart = null;
    let incomeDistChart = null;
    let incomeCompChart = null;
    let netWorthChart = null;
    let giniChart = null;

    function createCharts(results, useLand = false, showLaborChart = false, showConsumptionChart = false) {
        const years = results.map(r => r.year);
        const wc = results.map(r => r.wc);
        const wp = results.map(r => r.wp);
        const qc = results.map(r => r.qc);
        const qr = results.map(r => r.qr);
        const mu_h_c = results.map(r => r.mu_h_c);
        const mu_h_p = results.map(r => r.mu_h_p);
        const mu_h_c_min = results.map(r => r.mu_h_c_min);
        const mu_h_p_min = results.map(r => r.mu_h_p_min);
        const ell_c = results.map(r => r.ell_c);
        const r_rate = results.map(r => r.r);
        const share_KY = results.map(r => r.share_KY);
        const share_KC = results.map(r => r.share_KC);
        const share_KR = results.map(r => r.share_KR);

        // Factor income shares
        const capital_share = results.map(r => r.capital_share);
        const human_cog_share = results.map(r => r.human_cog_share);
        const human_phys_share = results.map(r => r.human_phys_share);
        const ai_share = results.map(r => r.ai_share);
        const robot_share = results.map(r => r.robot_share);

        // Implied technology levels (X = L/K, labor services per unit capital)
        // Normalize relative to base year
        const X_C_raw = results.map(r => r.AI_cog / r.K_C);
        const X_P_raw = results.map(r => r.R_phys / r.K_R);
        const X_C_0 = X_C_raw[0];
        const X_P_0 = X_P_raw[0];
        const X_C = X_C_raw.map(x => x / X_C_0);
        const X_P = X_P_raw.map(x => x / X_P_0);

        // Labor force data (for endogenous labor chart)
        const workingAgePop = results.map(r => r.WorkingAgePop);
        const L_endogenous = results.map(r => r.L_endogenous || r.H_cog);
        const H_data = results.map(r => r.H_data);

        // Destroy existing charts
        if (wagesChart) wagesChart.destroy();
        if (rentalCostChart) rentalCostChart.destroy();
        if (muChart) muChart.destroy();
        if (ellChart) ellChart.destroy();
        if (capitalChart) capitalChart.destroy();
        if (interestChart) interestChart.destroy();
        if (factorIncomeChart) factorIncomeChart.destroy();
        if (techChart) techChart.destroy();
        if (laborChart) laborChart.destroy();
        if (wageIncomeChart) wageIncomeChart.destroy();
        if (ubiTransferChart) ubiTransferChart.destroy();
        if (outputChart) outputChart.destroy();
        if (landRentChart) landRentChart.destroy();
        if (landUseShareChart) landUseShareChart.destroy();
        if (landIncomeShareChart) landIncomeShareChart.destroy();
        if (incomeDistChart) incomeDistChart.destroy();
        if (incomeCompChart) incomeCompChart.destroy();
        if (netWorthChart) netWorthChart.destroy();
        if (giniChart) giniChart.destroy();

        // Wages and Machine Prices chart
        const trust_wage = results.map(r => r.trust_wage || null);
        const hasTrustWage = trust_wage.some(v => v !== null && v > 0);

        const wagesCtx = document.getElementById('wagesChart').getContext('2d');
        const wagesDatasets = [
                    {
                        label: 'Human Cognitive Wage',
                        data: wc,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'AI Cognitive Wage',
                        data: qc,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Human Physical Wage',
                        data: wp,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Robot Physical Wage',
                        data: qr,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    }
        ];
        if (hasTrustWage) {
            wagesDatasets.push({
                label: 'Trusted Labor Wage',
                data: trust_wage,
                borderColor: 'rgb(220, 20, 60)',
                backgroundColor: 'rgb(220, 20, 60)',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                spanGaps: true
            });
        }
        wagesChart = new Chart(wagesCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: wagesDatasets
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Wages per human equivalent worker'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Price / wage (per human equivalent)'
                        },
                        min: 100
                    }
                }
            }
        });

        // Rental Cost chart — actual per-unit costs (not per human equivalent)
        // Lines: AI copy rental, Robot rental, H100e rental
        const rental_ai_copy = results.map((r, i) => r.qc * (r.equivs_per_ai || results[i].equivs_per_ai || 1));
        const rental_robot = results.map((r, i) => r.qr * (r.equivs_per_robot || results[i].equivs_per_robot || 1));
        const rental_h100e = results.map((r, i) => {
            const ai_copy_cost = r.qc * (r.equivs_per_ai || results[i].equivs_per_ai || 1);
            const h100e_per_copy = r.h100e_per_ai_copy || results[i].h100e_per_ai_copy || 1;
            return ai_copy_cost / h100e_per_copy;
        });

        const rentalCtx = document.getElementById('rentalCostChart').getContext('2d');
        rentalCostChart = new Chart(rentalCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'AI copy rental (yearly)',
                        data: rental_ai_copy,
                        borderColor: 'rgb(44, 160, 44)',
                        backgroundColor: 'rgb(44, 160, 44)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Robot rental (yearly)',
                        data: rental_robot,
                        borderColor: 'rgb(214, 39, 40)',
                        backgroundColor: 'rgb(214, 39, 40)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'H100e rental (yearly)',
                        data: rental_h100e,
                        borderColor: 'rgb(148, 103, 189)',
                        backgroundColor: 'rgb(148, 103, 189)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Rental costs over time (per actual unit)'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Annual rental cost (log scale)'
                        }
                    }
                }
            }
        });

        // Mu terms chart
        const muCtx = document.getElementById('muChart').getContext('2d');
        muChart = new Chart(muCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Cognitive: automated (eq)',
                        data: mu_h_c.map(m => 1 - m),
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Cognitive: automatable (frontier)',
                        data: mu_h_c_min.map(m => 1 - m),
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Physical: automated (eq)',
                        data: mu_h_p.map(m => 1 - m),
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Physical: automatable (frontier)',
                        data: mu_h_p_min.map(m => 1 - m),
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Automatable vs automated task shares'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Task share'
                        },
                        min: 0,
                        max: 1
                    }
                }
            }
        });

        // Labor allocation chart (absolute worker counts, stacked area)
        const H_cog_data = results.map(r => r.H_cog_allocated || r.Hc || 0);
        const H_phys_data = results.map(r => r.H_phys_allocated || r.Hp || 0);
        const H_trust_data = results.map(r => r.H_trust || 0);
        const hasTrustWorkers = H_trust_data.some(v => v > 0);
        const ellCtx = document.getElementById('ellChart').getContext('2d');
        const ellDatasets = [
                    {
                        label: 'Cognitive Workers',
                        data: H_cog_data,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgba(31, 119, 180, 0.5)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    },
                    {
                        label: 'Physical Workers',
                        data: H_phys_data,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgba(255, 127, 14, 0.5)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }
        ];
        if (hasTrustWorkers) {
            ellDatasets.push({
                label: 'Trusted Workers',
                data: H_trust_data,
                borderColor: 'rgb(220, 20, 60)',
                backgroundColor: 'rgba(220, 20, 60, 0.5)',
                borderWidth: 2,
                fill: true,
                tension: 0.1
            });
        }
        ellChart = new Chart(ellCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: ellDatasets
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Human labor allocation over time'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Number of Workers'
                        },
                        min: 0
                    }
                }
            }
        });

        // Capital allocation shares chart (stacked area)
        const capitalCtx = document.getElementById('capitalChart').getContext('2d');
        capitalChart = new Chart(capitalCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Other Capital (excl. land)',
                        data: share_KY,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgba(31, 119, 180, 0.7)',
                        borderWidth: 1,
                        fill: true,
                        tension: 0.1
                    },
                    {
                        label: 'Compute',
                        data: share_KC,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgba(255, 127, 14, 0.7)',
                        borderWidth: 1,
                        fill: true,
                        tension: 0.1
                    },
                    {
                        label: 'Robot',
                        data: share_KR,
                        borderColor: 'rgb(44, 160, 44)',
                        backgroundColor: 'rgba(44, 160, 44, 0.7)',
                        borderWidth: 1,
                        fill: true,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Productive capital allocation shares over time'
                    },
                    legend: {
                        position: 'bottom'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Share of total productive capital'
                        },
                        min: 0,
                        max: 1
                    }
                }
            }
        });

        // Interest rate chart
        const interestCtx = document.getElementById('interestChart').getContext('2d');
        interestChart = new Chart(interestCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'r (return to productive capital)',
                        data: r_rate,
                        borderColor: 'rgb(44, 160, 44)',
                        backgroundColor: 'rgb(44, 160, 44)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Implied return to productive capital over time'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Return to productive capital (log scale)'
                        }
                    }
                }
            }
        });

        // Factor Income Shares chart (stacked area)
        const factorCtx = document.getElementById('factorIncomeChart').getContext('2d');

        // Build factor datasets
        const factorDatasets = [
            {
                label: 'Productive Capital',
                data: capital_share,
                borderColor: 'rgb(150, 150, 150)',
                backgroundColor: 'rgba(150, 150, 150, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            },
            {
                label: 'Human Cognitive',
                data: human_cog_share,
                borderColor: 'rgb(31, 119, 180)',
                backgroundColor: 'rgba(31, 119, 180, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            },
            {
                label: 'Human Physical',
                data: human_phys_share,
                borderColor: 'rgb(44, 160, 44)',
                backgroundColor: 'rgba(44, 160, 44, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            },
            {
                label: 'AI Services',
                data: ai_share,
                borderColor: 'rgb(148, 103, 189)',
                backgroundColor: 'rgba(148, 103, 189, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            },
            {
                label: 'Robot Services',
                data: robot_share,
                borderColor: 'rgb(255, 127, 14)',
                backgroundColor: 'rgba(255, 127, 14, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            },
        ];

        // Add trusted labor income share (always on, but only shows when > 0)
        const trust_income_share = results.map(r => r.trust_income_share || 0);
        if (trust_income_share.some(v => v > 1e-6)) {
            factorDatasets.push({
                label: 'Trusted Labor',
                data: trust_income_share,
                borderColor: 'rgb(220, 20, 60)',
                backgroundColor: 'rgba(220, 20, 60, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            });
        }

        // Add land income share if in land mode
        if (useLand) {
            const land_income_share = results.map(r => r.land_income_share || 0);
            factorDatasets.push({
                label: 'Land',
                data: land_income_share,
                borderColor: 'rgb(139, 69, 19)',
                backgroundColor: 'rgba(139, 69, 19, 0.8)',
                borderWidth: 1,
                fill: true,
                tension: 0.1
            });
        }

        factorIncomeChart = new Chart(factorCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: factorDatasets
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Factor income shares over time'
                    },
                    legend: {
                        position: 'bottom'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Share of GWP'
                        },
                        min: 0,
                        max: 1
                    }
                }
            }
        });

        // (Implied) Technology Levels chart (log scale)
        const techCtx = document.getElementById('techChart').getContext('2d');
        techChart = new Chart(techCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'X_C (Cognitive)',
                        data: X_C,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'X_P (Physical)',
                        data: X_P,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: '(Implied) Technology levels over time'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Relative Tech Levels'
                        }
                    }
                }
            }
        });

        // Labor Force and Working Age Population chart
        // Only show if endogenous labor supply is enabled
        const laborChartContainer = document.getElementById('laborChart').closest('.chart-container');
        if (showLaborChart) {
            laborChartContainer.style.display = '';
            const laborCtx = document.getElementById('laborChart').getContext('2d');
            const L_trust_chart = results.map(r => r.H_trust || 0);
            const hasTrustInLabor = L_trust_chart.some(v => v > 0);
            const laborDatasets = [
                {
                    label: 'Working Age Population',
                    data: workingAgePop,
                    borderColor: 'rgb(150, 150, 150)',
                    backgroundColor: 'rgb(150, 150, 150)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                },
                {
                    label: 'Implied Labor Force',
                    data: L_endogenous,
                    borderColor: 'rgb(31, 119, 180)',
                    backgroundColor: 'rgb(31, 119, 180)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                },
                {
                    label: 'Labor Force (Data)',
                    data: H_data,
                    borderColor: 'rgb(255, 127, 14)',
                    backgroundColor: 'rgb(255, 127, 14)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.1
                }
            ];
            if (hasTrustInLabor) {
                laborDatasets.push({
                    label: 'Trusted Workers',
                    data: L_trust_chart,
                    borderColor: 'rgb(220, 20, 60)',
                    backgroundColor: 'rgb(220, 20, 60)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                });
            }

            laborChart = new Chart(laborCtx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: laborDatasets
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Labor force and working age population over time'
                        },
                        legend: {
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Year'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Population'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        } else {
            laborChartContainer.style.display = 'none';
        }

        // Household Income per Worker (single stacked chart)
        const incomeChartsContainer = document.getElementById('incomeChartsContainer');

        if (showConsumptionChart) {
            incomeChartsContainer.style.display = '';

            const params = getParams();
            const wage_per_worker = results.map(r => r.wage_per_worker || 0);
            const T_capital_per_worker = results.map(r => r.T_capital_per_worker || 0);
            const T_AI_per_worker = results.map(r => r.T_AI_per_worker || 0);
            const T_robot_per_worker = results.map(r => r.T_robot_per_worker || 0);

            // Wage Income chart (always shown)
            wageIncomeChart = new Chart(document.getElementById('wageIncomeChart').getContext('2d'), {
                type: 'line',
                data: {
                    labels: years,
                    datasets: [{
                        label: 'Wage Income',
                        data: wage_per_worker,
                        borderColor: 'rgb(44, 160, 44)',
                        backgroundColor: 'rgba(44, 160, 44, 0.2)',
                        borderWidth: 2, fill: true, tension: 0.1, pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Wage Income' },
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Year' } },
                        y: { type: 'logarithmic', title: { display: true, text: '$ per Worker' }, min: 10000 }
                    }
                }
            });

            // UBI Transfers chart (shown if any tax > 0, lines on log scale)
            var ubiContainer = document.getElementById('ubiTransferChartContainer');
            var showAnyTax = params.tau_R > 0 || params.tau_AI > 0 || params.tau_k > 0;
            if (showAnyTax) {
                ubiContainer.style.display = '';
                var ubiDatasets = [];
                if (params.tau_R > 0) {
                    ubiDatasets.push({
                        label: 'UBI (Robot Tax)',
                        data: T_robot_per_worker,
                        borderColor: 'rgb(255, 127, 14)',
                        borderWidth: 2, fill: false, tension: 0.1, pointRadius: 0
                    });
                }
                if (params.tau_AI > 0) {
                    ubiDatasets.push({
                        label: 'UBI (AI Tax)',
                        data: T_AI_per_worker,
                        borderColor: 'rgb(148, 103, 189)',
                        borderWidth: 2, fill: false, tension: 0.1, pointRadius: 0
                    });
                }
                if (params.tau_k > 0) {
                    ubiDatasets.push({
                        label: 'UBI (Capital Tax)',
                        data: T_capital_per_worker,
                        borderColor: 'rgb(150, 150, 150)',
                        borderWidth: 2, fill: false, tension: 0.1, pointRadius: 0
                    });
                }
                // Add wage as a reference line
                ubiDatasets.push({
                    label: 'Wage Income',
                    data: wage_per_worker,
                    borderColor: 'rgb(44, 160, 44)',
                    borderWidth: 2, fill: false, tension: 0.1, pointRadius: 0
                });
                ubiTransferChart = new Chart(document.getElementById('ubiTransferChart').getContext('2d'), {
                    type: 'line',
                    data: { labels: years, datasets: ubiDatasets },
                    options: {
                        responsive: true,
                        plugins: {
                            title: { display: true, text: 'UBI Transfers per Worker' },
                            legend: { position: 'top' }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Year' } },
                            y: { type: 'logarithmic', title: { display: true, text: '$ per Worker' }, min: 1 }
                        }
                    }
                });
            } else {
                ubiContainer.style.display = 'none';
            }
        } else {
            incomeChartsContainer.style.display = 'none';
        }

        // Output: Forecast vs Model Prediction chart
        const Y_forecast = results.map(r => r.Y_forecast || r.Y);
        const Y_predicted = results.map(r => r.Y_predicted || r.Y);

        // GATE GWP data (2025-2040)
        const GATE_GWP = [
            1.31e14, 1.28e14, 1.57e14, 2.02e14, 2.59e14, 3.36e14, 4.45e14, 6.17e14,
            9.07e14, 1.43e15, 2.51e15, 5.19e15, 1.4e16, 5.6e16, 2.89e17, 1.45e18
        ];
        // Slice to match the number of years in results
        const GATE_GWP_data = GATE_GWP.slice(0, years.length);

        const outputCtx = document.getElementById('outputChart').getContext('2d');
        outputChart = new Chart(outputCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Output Forecast (Spreadsheet)',
                        data: Y_forecast,
                        borderColor: 'rgb(150, 150, 150)',
                        backgroundColor: 'rgb(150, 150, 150)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Output Model Prediction',
                        data: Y_predicted,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'GATE GWP',
                        data: GATE_GWP_data,
                        borderColor: 'rgb(44, 160, 44)',
                        backgroundColor: 'rgb(44, 160, 44)',
                        borderWidth: 2,
                        borderDash: [10, 5],
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Output: Forecast vs Model Prediction'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Output (log scale)'
                        }
                    }
                }
            }
        });

        // Land Rent per Hectare chart — 5 categories
        const landRentContainer = document.getElementById('landRentContainer');
        if (useLand && results[0].rent_per_ha) {
            landRentContainer.style.display = '';
            const rentDatasets = LAND_CATEGORIES.map(cat => ({
                label: LAND_CATEGORY_LABELS[cat] + ' ($/ha/yr)',
                data: results.map(r => r.rent_per_ha ? r.rent_per_ha[cat] : null),
                borderColor: LAND_COLORS[cat].border,
                backgroundColor: LAND_COLORS[cat].border,
                borderWidth: 2,
                fill: false,
                tension: 0.1
            }));
            const landRentCtx = document.getElementById('landRentChart').getContext('2d');
            landRentChart = new Chart(landRentCtx, {
                type: 'line',
                data: { labels: years, datasets: rentDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Land Rent per Hectare by Category' },
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Year' } },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: '$/ha/year (log scale)' }
                        }
                    }
                }
            });
        } else {
            landRentContainer.style.display = 'none';
        }

        // Physical Land Use Shares chart — 5 categories stacked to 100%
        const landUseShareContainer = document.getElementById('landUseShareContainer');
        if (useLand && results.length > 0 && results[0].physical_land) {
            landUseShareContainer.style.display = '';
            const useShareData = results.map(r => {
                if (!r.physical_land) return null;
                var total = 0;
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) total += r.physical_land[LAND_CATEGORIES[ci]] || 0;
                var shares = {};
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                    var cat = LAND_CATEGORIES[ci];
                    shares[cat] = total > 0 ? (r.physical_land[cat] || 0) / total : 0;
                }
                return shares;
            });
            const useShareDatasets = LAND_CATEGORIES.map(cat => ({
                label: LAND_CATEGORY_LABELS[cat],
                data: useShareData.map(s => s ? s[cat] * 100 : null),
                borderColor: LAND_COLORS[cat].border,
                backgroundColor: LAND_COLORS[cat].bg,
                borderWidth: 1,
                fill: true,
                tension: 0.1
            }));
            const landUseShareCtx = document.getElementById('landUseShareChart').getContext('2d');
            landUseShareChart = new Chart(landUseShareCtx, {
                type: 'line',
                data: { labels: years, datasets: useShareDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Physical Land Use Shares by Category' },
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Year' } },
                        y: {
                            stacked: true,
                            title: { display: true, text: '% of total land area' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        } else {
            landUseShareContainer.style.display = 'none';
        }

        // Land Income Share chart — 5 categories stacked to 100%
        const landIncomeShareContainer = document.getElementById('landIncomeShareContainer');
        if (useLand && results[0].revenue_per_category) {
            landIncomeShareContainer.style.display = '';
            const shareData = results.map(r => {
                if (!r.revenue_per_category) return null;
                var total = 0;
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) total += r.revenue_per_category[LAND_CATEGORIES[ci]] || 0;
                var shares = {};
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                    var cat = LAND_CATEGORIES[ci];
                    shares[cat] = total > 0 ? (r.revenue_per_category[cat] || 0) / total : 0;
                }
                return shares;
            });
            const shareDatasets = LAND_CATEGORIES.map(cat => ({
                label: LAND_CATEGORY_LABELS[cat],
                data: shareData.map(s => s ? s[cat] * 100 : null),
                borderColor: LAND_COLORS[cat].border,
                backgroundColor: LAND_COLORS[cat].bg,
                borderWidth: 1,
                fill: true,
                tension: 0.1
            }));
            const landIncomeShareCtx = document.getElementById('landIncomeShareChart').getContext('2d');
            landIncomeShareChart = new Chart(landIncomeShareCtx, {
                type: 'line',
                data: { labels: years, datasets: shareDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Land Revenue Shares by Category (% of total land income)' },
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Year' } },
                        y: {
                            stacked: true,
                            title: { display: true, text: '% of total land revenue' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        } else {
            landIncomeShareContainer.style.display = 'none';
        }
    }

    // Store distribution data for year toggle
    var _cachedDistribution = null;
    var _cachedDistLabels = null;
    var _cachedResults = null;
    var _cachedParams = null;

    function buildIncomeCompChart(distribution, yearIdx, percentiles, results, params) {
        if (incomeCompChart) incomeCompChart.destroy();
        var d = distribution[yearIdx];
        var r = results ? results[yearIdx] : null;
        var p = params;
        if (!r || !p) return;

        var smooth = computeSmoothDistribution(r, p);
        var fields = ['wage', 'capital', 'ai', 'robot', 'land', 'trust', 'ubi'];

        // Convert component arrays to % at each point (shares sum to 100%)
        function compData(field) {
            var arr = smooth.components[field];
            var out = [];
            for (var i = 0; i < arr.length; i++) {
                var total = 0;
                for (var f = 0; f < fields.length; f++) {
                    total += Math.max(smooth.components[fields[f]][i].y, 0);
                }
                out.push({ x: arr[i].x, y: total > 0 ? (Math.max(arr[i].y, 0) / total) * 100 : 0 });
            }
            return out;
        }

        var incomeCompCtx = document.getElementById('incomeCompChart').getContext('2d');
        incomeCompChart = new Chart(incomeCompCtx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Wage',
                        data: compData('wage'),
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgba(31, 119, 180, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    },
                    {
                        label: 'Capital',
                        data: compData('capital'),
                        borderColor: 'rgb(150, 150, 150)',
                        backgroundColor: 'rgba(150, 150, 150, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    },
                    {
                        label: 'AI',
                        data: compData('ai'),
                        borderColor: 'rgb(148, 103, 189)',
                        backgroundColor: 'rgba(148, 103, 189, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    },
                    {
                        label: 'Robot',
                        data: compData('robot'),
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgba(255, 127, 14, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    },
                    {
                        label: 'Land',
                        data: compData('land'),
                        borderColor: 'rgb(139, 69, 19)',
                        backgroundColor: 'rgba(139, 69, 19, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    },
                    {
                        label: 'Trusted Labor',
                        data: compData('trust'),
                        borderColor: 'rgb(220, 20, 60)',
                        backgroundColor: 'rgba(220, 20, 60, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    },
                    {
                        label: 'UBI',
                        data: compData('ubi'),
                        borderColor: 'rgb(44, 160, 44)',
                        backgroundColor: 'rgba(44, 160, 44, 0.7)',
                        borderWidth: 1, fill: true, tension: 0, pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Income Composition by Percentile (' + d.year + ')' },
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(ctx) {
                                return ctx.dataset.label + ': ' + ctx.parsed.y.toFixed(1) + '%';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Percentile' },
                        min: 5, max: 100
                    },
                    y: {
                        stacked: true,
                        title: { display: true, text: '% of Household Income' },
                        min: 0,
                        max: 100
                    }
                }
            }
        });
    }

    function createDistributionCharts(distribution, results, params) {
        var incomeDistContainer = document.getElementById('incomeDistContainer');
        var incomeCompContainer = document.getElementById('incomeCompContainer');
        var netWorthContainer = document.getElementById('netWorthContainer');
        var giniContainer = document.getElementById('giniContainer');

        if (!distribution || distribution.length === 0) {
            incomeDistContainer.style.display = 'none';
            incomeCompContainer.style.display = 'none';
            netWorthContainer.style.display = 'none';
            giniContainer.style.display = 'none';
            _cachedDistribution = null;
            return;
        }

        incomeDistContainer.style.display = '';
        incomeCompContainer.style.display = '';
        netWorthContainer.style.display = '';
        giniContainer.style.display = '';

        // Numeric percentile values for x-axis (linear scale, not categorical)
        var percentiles = distribution[0].households.map(function(h) { return h.percentile; });

        _cachedDistribution = distribution;
        _cachedDistLabels = percentiles;
        _cachedResults = results;
        _cachedParams = params;

        // Pick 4 snapshot years: base year, base+5, base+10, base+15
        var baseYear = distribution[0].year;
        var snapYears = [baseYear, baseYear + 5, baseYear + 10, baseYear + 15];
        var snapIndices = snapYears.map(function(y) {
            for (var i = 0; i < distribution.length; i++) {
                if (distribution[i].year === y) return i;
            }
            return -1;
        }).filter(function(i) { return i >= 0; });

        var snapColors = ['rgb(31, 119, 180)', 'rgb(214, 39, 40)', 'rgb(255, 127, 14)', 'rgb(44, 160, 44)'];

        // Pre-compute smooth distributions for snapshot years
        var smoothDists = {};
        for (var si = 0; si < snapIndices.length; si++) {
            var idx = snapIndices[si];
            smoothDists[idx] = computeSmoothDistribution(results[idx], params);
        }

        // ---- Income Distribution Chart (3 lines, log y, smooth from Lorenz derivatives) ----
        var incomeDatasets = snapIndices.map(function(idx, si) {
            return {
                label: String(distribution[idx].year),
                data: smoothDists[idx].income,
                borderColor: snapColors[si],
                backgroundColor: snapColors[si],
                borderWidth: 2,
                fill: false,
                tension: 0,
                pointRadius: 0
            };
        });

        var incomeDistCtx = document.getElementById('incomeDistChart').getContext('2d');
        incomeDistChart = new Chart(incomeDistCtx, {
            type: 'line',
            data: { datasets: incomeDatasets },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Household Income Distribution (per household)' },
                    legend: { position: 'top' }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Percentile' },
                        min: 5, max: 100
                    },
                    y: {
                        type: 'logarithmic',
                        title: { display: true, text: 'Annual Income ($, log scale)' }
                    }
                }
            }
        });

        // ---- Income Composition Chart (stacked area, linear y, with year toggle) ----
        // Populate year dropdown
        var yearSelect = document.getElementById('incomeCompYearSelect');
        yearSelect.innerHTML = '';
        var defaultSnapIdx = snapIndices.length - 1; // default to last snapshot (2040)
        for (var si = 0; si < snapIndices.length; si++) {
            var opt = document.createElement('option');
            opt.value = snapIndices[si];
            opt.textContent = String(distribution[snapIndices[si]].year);
            if (si === defaultSnapIdx) opt.selected = true;
            yearSelect.appendChild(opt);
        }

        // Build initial chart for last snapshot year (2040)
        buildIncomeCompChart(distribution, snapIndices[defaultSnapIdx], percentiles, results, params);

        // ---- Net Worth Distribution Chart (3 lines, log y, smooth from Lorenz derivatives) ----
        var nwDatasets = snapIndices.map(function(idx, si) {
            return {
                label: String(distribution[idx].year),
                data: smoothDists[idx].networth,
                borderColor: snapColors[si],
                backgroundColor: snapColors[si],
                borderWidth: 2,
                fill: false,
                tension: 0,
                pointRadius: 0
            };
        });

        var netWorthCtx = document.getElementById('netWorthChart').getContext('2d');
        netWorthChart = new Chart(netWorthCtx, {
            type: 'line',
            data: { datasets: nwDatasets },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Household Net Worth Distribution (per household)' },
                    legend: { position: 'top' }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Percentile' },
                        min: 5, max: 100
                    },
                    y: {
                        type: 'logarithmic',
                        title: { display: true, text: 'Net Worth ($, log scale)' }
                    }
                }
            }
        });

        // ---- Gini Coefficient Chart (2 lines: income & wealth over time) ----
        var giniYears = distribution.map(function(d) { return d.year; });
        var giniIncome = distribution.map(function(d) { return d.gini_income; });
        var giniWealth = distribution.map(function(d) { return d.gini_wealth; });

        var giniCtx = document.getElementById('giniChart').getContext('2d');
        giniChart = new Chart(giniCtx, {
            type: 'line',
            data: {
                labels: giniYears,
                datasets: [
                    {
                        label: 'Income Gini',
                        data: giniIncome,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 1
                    },
                    {
                        label: 'Wealth Gini',
                        data: giniWealth,
                        borderColor: 'rgb(214, 39, 40)',
                        backgroundColor: 'rgb(214, 39, 40)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Gini Coefficients' },
                    legend: { position: 'top' }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Year' }
                    },
                    y: {
                        title: { display: true, text: 'Gini Coefficient' },
                        min: 0, max: 1
                    }
                }
            }
        });
    }

    function createResultsTable(results, useLand = false) {
        const container = document.getElementById('tableContainer');

        let html = '<table><thead><tr>';
        html += '<th>Year</th><th>r</th><th>K_Y/K</th><th>K_C/K</th><th>K_R/K</th><th>mu_h_c</th><th>mu_h_p</th><th>w_c</th><th>q_c</th><th>w_p</th><th>q_p</th>';
        if (useLand) {
            html += '<th>Y_final</th><th>PY</th><th>Land %</th>';
            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                html += '<th>v_' + LAND_CATEGORIES[ci].substring(0, 4) + '</th>';
            }
        }
        html += '</tr></thead><tbody>';

        for (const row of results) {
            html += '<tr>';
            html += `<td>${row.year}</td>`;
            html += `<td>${row.r.toExponential(2)}</td>`;
            html += `<td>${row.share_KY.toFixed(4)}</td>`;
            html += `<td>${row.share_KC.toFixed(4)}</td>`;
            html += `<td>${row.share_KR.toFixed(4)}</td>`;
            html += `<td>${row.mu_h_c.toFixed(4)}</td>`;
            html += `<td>${row.mu_h_p.toFixed(4)}</td>`;
            html += `<td>${row.wc.toExponential(2)}</td>`;
            html += `<td>${row.qc.toExponential(2)}</td>`;
            html += `<td>${row.wp.toExponential(2)}</td>`;
            html += `<td>${row.qr.toExponential(2)}</td>`;
            if (useLand) {
                html += `<td>${row.Y_final.toExponential(2)}</td>`;
                html += `<td>${row.PY.toFixed(4)}</td>`;
                html += `<td>${(row.land_income_share * 100).toFixed(2)}%</td>`;
                for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                    var v = row.rent_per_ha ? row.rent_per_ha[LAND_CATEGORIES[ci]] : 0;
                    html += `<td>${v.toExponential(2)}</td>`;
                }
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
        document.getElementById('resultsTable').classList.remove('hidden');
    }

    // ========================================
    // Main App Logic
    // ========================================

    let loadedData = null;

    function showStatus(message, type) {
        const statusEl = document.getElementById('status');
        statusEl.textContent = message;
        statusEl.className = 'status ' + type;
        statusEl.classList.remove('hidden');
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const csvText = event.target.result;
                const parsed = parseCSV(csvText);
                populateTableFromLoadedData(parsed);
                showStatus(`Loaded ${parsed.length} years from "${file.name}". Review values in the table above.`, 'success');
            } catch (err) {
                showStatus('Error parsing file: ' + err.message, 'error');
            }
        };
        reader.readAsText(file);
    });

    document.getElementById('runModel').addEventListener('click', function() {
        try {
            loadedData = readTableData();
        } catch (err) {
            showStatus('Error reading scenario data: ' + err.message, 'error');
            return;
        }

        try {
            const useLand = isLandMode();
            const modeDescs = [];
            if (useLand) modeDescs.push('land');
            showStatus(`Running ${modeDescs.length ? modeDescs.join(' + ') + ' bottleneck' : 'baseline'} model...`, 'info');

            const params = getParams();

            // Prepare land parameters if in land mode (sequential CES nesting)
            let landParams = null;
            if (useLand) {
                const baseYear = loadedData[0].year;
                const isUS = isUSMode();
                const M_physical = isUS ? Object.assign({}, LAND_AREAS_US) : Object.assign({}, LAND_AREAS_WORLD);
                const gdpSharesRaw = isUS ? LAND_GDP_SHARES_US : LAND_GDP_SHARES_WORLD;

                // Scale GDP shares so they sum to user's s_L
                const rawSum = LAND_CATEGORIES.reduce(function(s, c) { return s + gdpSharesRaw[c]; }, 0);
                const scaleFactor = params.s_L / rawSum;
                const gdpShares = {};
                for (var c = 0; c < LAND_CATEGORIES.length; c++) {
                    gdpShares[LAND_CATEGORIES[c]] = gdpSharesRaw[LAND_CATEGORIES[c]] * scaleFactor;
                }

                // Calibrate conditional share parameters from GDP shares
                const s_vec = calibrateConditionalShares(gdpShares);

                // Per-category sigma from user inputs
                const sigma_vec = params.sigma_L_land;

                // Base-year C values (all 1.0)
                const C_vec = {};
                for (var c = 0; c < LAND_CATEGORIES.length; c++) C_vec[LAND_CATEGORIES[c]] = 1.0;

                // Normalize M̃_i so that C_i*M̃_i = Y_hat at base year for each category
                // This ensures Y_i = Y_{i-1} at every nesting level → Y_final = Y_hat
                const Y_0 = loadedData[0].Y;
                const M_vec = {};
                for (var c = 0; c < LAND_CATEGORIES.length; c++) {
                    M_vec[LAND_CATEGORIES[c]] = Y_0;  // C_i=1, so M̃_i = Y_0
                }
                // land_scale_i = M̃_i / M_physical_i (for converting rents back to $/ha)
                const land_scale = {};
                for (var c = 0; c < LAND_CATEGORIES.length; c++) {
                    var cat = LAND_CATEGORIES[c];
                    land_scale[cat] = M_vec[cat] / M_physical[cat];
                }

                landParams = {
                    s_L: params.s_L,
                    s_vec: s_vec,
                    sigma_vec: sigma_vec,
                    M_vec: M_vec,
                    M_physical: M_physical,
                    M_physical_init: Object.assign({}, M_physical),  // frozen copy for protection floors
                    C_vec: C_vec,
                    C_2040_land: params.C_2040_land,
                    baseYear: baseYear,
                    land_scale: land_scale,
                    gdpShares: gdpShares,
                    epsilon_supply: params.epsilon_supply,
                    protect_land: params.protect_land
                };
            }

            const useDistribution = isIncomeDistributionMode();
            const hasWorkingAgePop = loadedData[0].WorkingAgePop !== null;
            const doEndogenousLabor = useDistribution && hasWorkingAgePop;
            const doDistributionLabor = doEndogenousLabor; // alias for charts
            const doPredictedOutput = isPredictedOutputMode();

            // Pre-initialize households if distribution mode
            var distHouseholds = null;
            var distPopWeights = null;
            if (useDistribution) {
                distHouseholds = initializeHouseholds(params);
                // Population weight per bucket
                distPopWeights = [];
                for (var pw = 0; pw < 99; pw++) distPopWeights.push(0.01);
                for (var pw = 0; pw < 10; pw++) distPopWeights.push(0.001);
            }

            let results = [];

            if (doPredictedOutput) {
                // ========================================
                // PREDICTED OUTPUT MODE
                // ========================================
                const baseRow = loadedData[0];

                // Base year: K_0 = Y_0 / (Y/K ratio)
                const K_0 = params.initial_KY_ratio * baseRow.Y;
                const baseRowWithK = { ...baseRow, K: K_0 };

                // Solve base year to calibrate TFP (A)
                // Two-pass approach for CES normalization:
                // Pass 1: solve to get L_eff₀ (for CES normalization constants)
                // Pass 2: re-solve with normalization active so shares = α at base year
                let baseResult;

                // Pass 1: initial solve to determine base-year K_Y and L_eff
                baseResult = solveMuOneYear(baseRowWithK, params, landParams);

                // Store CES normalization constants: K₀_total and L_eff₀
                // pricesGivenMuAndZ uses total K in the CES nest, so normalize by K₀_total
                // At base year: cesTaskAgg(K₀/K₀, L_eff₀/L_eff₀) = cesTaskAgg(1, 1) = 1
                // So r = α × Y / K₀ and total capital share = α
                const sigma_K = params.sigma_K || 1.0;
                if (Math.abs(sigma_K - 1.0) >= 1e-10) {
                    params.K0_base = K_0;  // Total base-year capital (matches pricesGivenMuAndZ's K input)
                    params.Leff0_base = baseResult.L_eff;
                    // Pass 2: re-solve with normalization active
                    baseResult = solveMuOneYear(baseRowWithK, params, landParams);
                    // Update Leff0_base to match pass 2's L_eff for exact normalization
                    params.Leff0_base = baseResult.L_eff;
                }

                // Endogenous labor: calibrate from base year
                var B_po = null;
                if (doEndogenousLabor) {
                    var wbar_0_po = computeAverageWage(baseResult.wc, baseResult.wp, baseResult.ell_c);
                    var L_0_po = baseRow.H_data;
                    // Set wbar0 for new LFP model (distribution mode)
                    params.wbar0 = wbar_0_po;
                    // Keep legacy B calibration as fallback
                    B_po = calibrateLaborSupplyB(L_0_po, wbar_0_po, params.psi);
                }

                // Calibrate TFP: CES or Cobb-Douglas
                // With CES normalization: A = Y / cesTaskAgg(K_Y/K₀, 1) where K₀ = total capital
                const A = calibrateTFP(baseRow.Y, baseResult.K_Y, baseResult.L_eff, params.alpha, params.sigma_K, params.K0_base, params.Leff0_base);

                // Trust share calibrated on first year of activation (needs actual Y at that point)
                const trust_H = params.trust_num_workers;
                var trust_s = null;
                var prev_H_trust_val = null;  // Track H_trust across years for iteration seeding

                // Process each year
                let prev_Y = baseRow.Y;
                let prev_K = K_0;

                for (let i = 0; i < loadedData.length; i++) {
                    const row = loadedData[i];
                    let solution;
                    let K_t, Y_t;

                    // Update per-category land efficiency multipliers
                    if (landParams) {
                        for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                            landParams.C_vec[LAND_CATEGORIES[ci]] = computeLandProductivity_i(
                                row.year, landParams.baseYear, landParams.C_2040_land[LAND_CATEGORIES[ci]]
                            );
                        }
                    }

                    // Build trusted labor params for this year (H_trust solved endogenously)
                    var trustParams = null;
                    if (row.year >= params.trust_start_year) {
                        // Calibrate s_trust on first activation year using actual Y
                        if (trust_s === null) {
                            trust_s = calibrateTrustShare(
                                prev_Y,
                                1.0 * trust_H,
                                params.trust_initial_value,
                                params.trust_sigma
                            );
                        }
                        var C_trust = computeTrustEfficiency(row.year, params.trust_start_year, params.trust_C_2040);
                        trustParams = {
                            s_trust: trust_s,
                            sigma_trust: params.trust_sigma,
                            C_trust: C_trust,
                            H_trust_seed: trust_H,
                            prev_H_trust: prev_H_trust_val,
                            anchor_H_trust: (row.year === params.trust_start_year),
                            active: true
                        };
                    }

                    if (i === 0) {
                        // Base year: use spreadsheet Y and computed K_0
                        K_t = K_0;
                        Y_t = baseRow.Y;
                        solution = {
                            ...baseResult,
                            Y_predicted: Y_t,
                            Y_forecast: row.Y,
                            K_predicted: K_t,
                            K_forecast: row.K,
                            L_endogenous: baseRow.H_data,
                            participation_rate: baseRow.H_data / (row.WorkingAgePop || baseRow.H_data)
                        };
                    } else {
                        // Capital accumulation: K_t = s × Y_{t-1} + (1 - δ_K) × K_{t-1} + γ_R × R_phys_{t-1}
                        const prev_R_phys = loadedData[i - 1].R_phys || 0;
                        const robot_capital = (params.gamma_R || 0) * prev_R_phys;
                        K_t = params.savings_rate * prev_Y + (1.0 - params.delta_K) * prev_K + robot_capital;

                        // Create row with predicted K
                        const rowWithK = { ...row, K: K_t };

                        // Use previous year's predicted Y as initial guess
                        const Y_guess = prev_Y * 1.05;

                        if (doEndogenousLabor) {
                            solution = solveYearWithPredictedOutputAndEndogenousLabor(
                                rowWithK, params, landParams, A, B_po, row.WorkingAgePop, Y_guess, trustParams
                            );
                        } else {
                            solution = solveYearWithPredictedOutput(rowWithK, params, landParams, A, Y_guess, trustParams);
                        }

                        Y_t = solution.Y_predicted;
                        solution.K_predicted = K_t;
                        solution.K_forecast = row.K;
                    }

                    results.push({
                        year: row.year,
                        ...row,
                        K: K_t,  // Override with predicted K
                        ...solution
                    });

                    // Land conversion: reallocate physical areas based on rents
                    if (landParams && solution.rent_per_ha) {
                        applyLandConversion(landParams, solution.rent_per_ha);
                    }

                    prev_Y = Y_t;
                    prev_K = K_t;
                    if (solution.H_trust) prev_H_trust_val = solution.H_trust;
                }
            } else {
                // ========================================
                // SPREADSHEET MODE (original behavior)
                // ========================================

                // CES normalization: two-pass on base year to get K₀ and L_eff₀
                const sigma_K_sp = params.sigma_K || 1.0;
                if (Math.abs(sigma_K_sp - 1.0) >= 1e-10) {
                    const baseRow_sp = loadedData[0];
                    // Pass 1: get base-year L_eff
                    const baseResult_sp1 = solveMuOneYear(baseRow_sp, params, landParams);
                    params.K0_base = baseRow_sp.K;  // Total base-year capital from spreadsheet
                    params.Leff0_base = baseResult_sp1.L_eff;
                    // Pass 2: re-solve with normalization and update L_eff
                    const baseResult_sp2 = solveMuOneYear(baseRow_sp, params, landParams);
                    params.Leff0_base = baseResult_sp2.L_eff;
                }

                // Calibrate trusted labor share using Y at trust start year
                const trust_H_sp = params.trust_num_workers;
                var trust_Y_sp = loadedData[0].Y;
                for (var ti = 0; ti < loadedData.length; ti++) {
                    if (loadedData[ti].year >= params.trust_start_year) {
                        trust_Y_sp = loadedData[ti].Y;
                        break;
                    }
                }
                const trust_s_sp = calibrateTrustShare(
                    trust_Y_sp,
                    1.0 * trust_H_sp,
                    params.trust_initial_value,
                    params.trust_sigma
                );

                // Helper to build per-year trustParams (H_trust solved endogenously)
                var prev_H_trust_sp = null;
                function buildTrustParams_sp(year) {
                    if (year < params.trust_start_year) return null;
                    var C_trust = computeTrustEfficiency(year, params.trust_start_year, params.trust_C_2040);
                    return {
                        s_trust: trust_s_sp,
                        sigma_trust: params.trust_sigma,
                        C_trust: C_trust,
                        H_trust_seed: trust_H_sp,
                        prev_H_trust: prev_H_trust_sp,
                        anchor_H_trust: (year === params.trust_start_year),
                        active: true
                    };
                }

                if (doEndogenousLabor) {
                    // Endogenous labor supply
                    const baseRow = loadedData[0];
                    const baseResult = solveMuOneYear(baseRow, params, landParams);
                    var wbar_0_sp = computeAverageWage(baseResult.wc, baseResult.wp, baseResult.ell_c);
                    var L_0_sp = baseRow.H_data;
                    // Set wbar0 for new LFP model (distribution mode)
                    params.wbar0 = wbar_0_sp;
                    // Keep legacy B calibration as fallback
                    var B_sp = calibrateLaborSupplyB(L_0_sp, wbar_0_sp, params.psi);

                    for (let i = 0; i < loadedData.length; i++) {
                        const row = loadedData[i];
                        if (landParams) {
                            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                                landParams.C_vec[LAND_CATEGORIES[ci]] = computeLandProductivity_i(
                                    row.year, landParams.baseYear, landParams.C_2040_land[LAND_CATEGORIES[ci]]
                                );
                            }
                        }
                        const workingAgePop = row.WorkingAgePop;
                        const trustParams = buildTrustParams_sp(row.year);
                        const solution = solveWithEndogenousLabor(row, params, landParams, B_sp, workingAgePop, trustParams);
                        results.push({
                            year: row.year,
                            ...row,
                            ...solution,
                            Y_predicted: row.Y,
                            Y_forecast: row.Y
                        });
                        if (solution.H_trust) prev_H_trust_sp = solution.H_trust;
                        if (landParams && solution.rent_per_ha) {
                            applyLandConversion(landParams, solution.rent_per_ha);
                        }
                    }
                } else {
                    // Simple mode: use spreadsheet values directly
                    for (let i = 0; i < loadedData.length; i++) {
                        const row = loadedData[i];
                        // Update per-category land efficiency and recompute L_agg
                        if (landParams) {
                            for (var ci = 0; ci < LAND_CATEGORIES.length; ci++) {
                                landParams.C_vec[LAND_CATEGORIES[ci]] = computeLandProductivity_i(
                                    row.year, landParams.baseYear, landParams.C_2040_land[LAND_CATEGORIES[ci]]
                                );
                            }
                        }
                        const trustParams = buildTrustParams_sp(row.year);
                        const solution = solveMuOneYear(row, params, landParams, trustParams);
                        results.push({
                            year: row.year,
                            ...row,
                            ...solution,
                            Y_predicted: row.Y,
                            Y_forecast: row.Y
                        });
                        if (solution.H_trust) prev_H_trust_sp = solution.H_trust;
                        if (landParams && solution.rent_per_ha) {
                            applyLandConversion(landParams, solution.rent_per_ha);
                        }
                    }
                }
            }

            const useTaxation = isTaxationMode();

            // Income distribution post-processing (charts only — labor already integrated)
            if (useDistribution) {
                var distribution = computeIncomeDistribution(results, distHouseholds, params);
                createCharts(results, useLand, doDistributionLabor, useTaxation);
                createDistributionCharts(distribution, results, params);
            } else {
                createCharts(results, useLand, doDistributionLabor, useTaxation);
                createDistributionCharts(null, null, null);
            }

            createResultsTable(results, useLand);

            const bottlenecks = [];
            if (useLand) bottlenecks.push('land');
            const modeStr = bottlenecks.length ? bottlenecks.join(' + ') + ' bottleneck' : 'baseline';
            const laborStr = doEndogenousLabor ? ' with endogenous labor' : '';
            const taxStr = useTaxation ? ' with taxation' : '';
            const predictStr = doPredictedOutput ? ' with predicted Y & K' : '';
            const distStr = useDistribution ? ' with income distribution' : '';
            showStatus(`Model (${modeStr}${laborStr}${taxStr}${predictStr}${distStr}) completed successfully!`, 'success');
        } catch (err) {
            showStatus('Error running model: ' + err.message, 'error');
            console.error(err);
        }
    });

    // Toggle land parameter visibility
    document.getElementById('useLand').addEventListener('change', function() {
        const useLand = this.checked;
        document.getElementById('landParams').classList.toggle('hidden', !useLand);
    });

    // Toggle tax parameters visibility
    document.getElementById('useTaxation').addEventListener('change', function() {
        const useTaxation = this.checked;
        document.getElementById('taxParams').classList.toggle('hidden', !useTaxation);
    });

    // Toggle capital accumulation parameters visibility
    document.getElementById('usePredictedOutput').addEventListener('change', function() {
        const usePredictedOutput = this.checked;
        document.getElementById('capitalAccumParams').classList.toggle('hidden', !usePredictedOutput);
    });

    // Toggle income distribution parameters visibility
    document.getElementById('useIncomeDistribution').addEventListener('change', function() {
        document.getElementById('incomeDistParams').classList.toggle('hidden', !this.checked);
        // Toggle labor supply parameter visibility: psi when dist off, LFP params when dist on
        document.getElementById('psiParams').classList.toggle('hidden', this.checked);
        document.getElementById('lfpParams').classList.toggle('hidden', !this.checked);
    });

    // Income composition year toggle
    document.getElementById('incomeCompYearSelect').addEventListener('change', function() {
        if (_cachedDistribution && _cachedDistLabels && _cachedResults && _cachedParams) {
            buildIncomeCompChart(_cachedDistribution, parseInt(this.value), _cachedDistLabels, _cachedResults, _cachedParams);
        }
    });

    // Download CSV (exports table + background defaults)
    document.getElementById('downloadTemplate').addEventListener('click', function() {
        const table = document.getElementById('scenarioTable');
        const rows = table.querySelectorAll('tbody tr');
        var usMode = isUSMode();
        var bgDefaults = usMode ? BACKGROUND_DEFAULTS_US : BACKGROUND_DEFAULTS_GLOBAL;

        var csv = ',' + TEMPLATE_YEARS.join(',') + '\n';

        // Background rows
        for (var label in bgDefaults) {
            csv += label + ',' + bgDefaults[label].join(',') + '\n';
        }

        // Editable rows from table
        rows.forEach(function(tr) {
            var label = tr.getAttribute('data-row-label');
            var inputs = tr.querySelectorAll('input');
            var values = Array.from(inputs).map(function(inp) { return inp.value.trim(); });
            csv += label + ',' + values.join(',') + '\n';
        });

        var blob = new Blob([csv], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'scenario_data.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });

    // Get template rows for current mode
    function getTemplateRowsForMode() {
        return TEMPLATE_ROWS;
    }

    // Reset Defaults
    document.getElementById('resetDefaults').addEventListener('click', function() {
        var shares = isUSMode() ? US_SHARE_ROWS : null;
        buildScenarioTable(getTemplateRowsForMode(), TEMPLATE_YEARS, shares);
        showStatus('Table reset to default values.', 'info');
    });

    // Populate base-year economy inputs from the appropriate defaults
    function updateBaseYearInputs() {
        var bg = isUSMode() ? BACKGROUND_DEFAULTS_US : BACKGROUND_DEFAULTS_GLOBAL;
        document.getElementById('base_Y').value = bg["Output"][0];
        document.getElementById('base_L').value = bg["Human Labor Force"][0];
        document.getElementById('base_WAP').value = bg["Human Working Age Population"][0];
    }

    // US/Global toggle — rebuild table with/without share rows and update base-year inputs
    document.getElementById('useUSMode').addEventListener('change', function() {
        var shares = isUSMode() ? US_SHARE_ROWS : null;
        buildScenarioTable(getTemplateRowsForMode(), TEMPLATE_YEARS, shares);
        updateBaseYearInputs();
    });

    // Initialize scenario table with defaults on page load (US mode is default)
    buildScenarioTable(getTemplateRowsForMode(), TEMPLATE_YEARS, US_SHARE_ROWS);
    updateBaseYearInputs();
    </script>
</body>
</html>
