<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Growth Model</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .upload-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .upload-section h2 {
            margin-top: 0;
            color: #555;
        }
        .file-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        input[type="file"] {
            padding: 10px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        input[type="file"]:hover {
            border-color: #007bff;
        }
        .params-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .param-group {
            display: flex;
            flex-direction: column;
        }
        .param-group label {
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }
        .param-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .param-group small {
            color: #888;
            margin-top: 3px;
        }
        .param-section-title {
            color: #555;
            font-size: 14px;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .param-section-title:first-of-type {
            margin-top: 0;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .template-btn {
            background: #28a745;
            margin-top: 0;
        }
        .template-btn:hover {
            background: #1e7e34;
        }
        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            color: #555;
            text-align: center;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .status.error {
            background: #fee;
            color: #c00;
        }
        .status.success {
            background: #efe;
            color: #060;
        }
        .status.info {
            background: #eef;
            color: #006;
        }
        .hidden {
            display: none;
        }
        .results-table {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        th, td {
            padding: 8px;
            text-align: right;
            border-bottom: 1px solid #eee;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        td:first-child, th:first-child {
            text-align: left;
        }
    </style>
</head>
<body>
    <h1>Scenario Growth Model</h1>

    <div class="upload-section">
        <h2>Upload Spreadsheet</h2>
        <p>Upload a CSV file with economic scenario data. Download the template below for the required format.</p>
        <div class="file-input-wrapper">
            <input type="file" id="fileInput" accept=".csv">
            <button id="downloadTemplate" class="template-btn">Download Template</button>
        </div>
        <div id="status" class="status hidden"></div>
    </div>

    <div class="params-section">
        <h2>Model Parameters</h2>

        <h3 class="param-section-title">Choice Parameters (Elasticities)</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="eps">ε (cog vs phys)</label>
                <input type="number" id="eps" value="0.40" step="0.01" min="0.01">
                <small>Substitution between cognitive and physical</small>
            </div>
            <div class="param-group">
                <label for="sig_c">σ_c (human vs AI)</label>
                <input type="number" id="sig_c" value="0.50" step="0.01" min="0.01">
                <small>Substitution human vs AI (cognitive)</small>
            </div>
            <div class="param-group">
                <label for="sig_p">σ_p (human vs robot)</label>
                <input type="number" id="sig_p" value="0.50" step="0.01" min="0.01">
                <small>Substitution human vs robots (physical)</small>
            </div>
            <div class="param-group">
                <label for="omega">ω (labor elasticity)</label>
                <input type="number" id="omega" value="0.10" step="0.1" min="0">
                <small>L_c/L_p = κ · (w_c/w_p)^ω</small>
            </div>
        </div>

        <h3 class="param-section-title">Target Parameters</h3>
        <div class="params-grid">
            <div class="param-group">
                <label for="alpha">α (capital share)</label>
                <input type="number" id="alpha" value="0.30" step="0.01" min="0" max="1">
                <small>Cobb-Douglas capital share</small>
            </div>
            <div class="param-group">
                <label for="kappa">κ (labor ratio scale)</label>
                <input type="number" id="kappa" value="1.68" step="0.1" min="0.01">
                <small>Scale factor in L_c/L_p</small>
            </div>
            <div class="param-group">
                <label for="theta">θ (cognitive weight)</label>
                <input type="number" id="theta" value="0.68" step="0.01" min="0" max="1">
                <small>Weight on cognitive in L_eff CES</small>
            </div>
        </div>

        <button id="runModel" disabled>Run Model</button>
    </div>

    <div class="charts-section">
        <div class="chart-container">
            <h3>Wages and Machine Prices over Time</h3>
            <canvas id="wagesChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Human Task Shares (μ terms)</h3>
            <canvas id="muChart"></canvas>
        </div>
    </div>

    <div id="resultsTable" class="results-table hidden">
        <h3>Detailed Results</h3>
        <div id="tableContainer"></div>
    </div>

    <script>
    // ========================================
    // Economic Model (ported from Python)
    // ========================================

    const TINY = 1e-12;

    // Get parameters from inputs
    function getParams() {
        return {
            alpha: parseFloat(document.getElementById('alpha').value),
            theta: parseFloat(document.getElementById('theta').value),
            eps: parseFloat(document.getElementById('eps').value),
            sig_c: parseFloat(document.getElementById('sig_c').value),
            sig_p: parseFloat(document.getElementById('sig_p').value),
            kappa: parseFloat(document.getElementById('kappa').value),
            omega: parseFloat(document.getElementById('omega').value)
        };
    }

    // CES task aggregator
    function cesTaskAgg(x, y, mu, sigma) {
        x = Math.max(x, TINY);
        y = Math.max(y, TINY);
        mu = Math.max(TINY, Math.min(mu, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            // Cobb-Douglas limit
            return Math.pow(x, mu) * Math.pow(y, 1.0 - mu);
        }

        const rho = (sigma - 1.0) / sigma;
        const term1 = Math.pow(mu, 1.0 / sigma) * Math.pow(x, rho);
        const term2 = Math.pow(1.0 - mu, 1.0 / sigma) * Math.pow(y, rho);
        return Math.pow(term1 + term2, 1.0 / rho);
    }

    // Derivative wrt first input (weight mu)
    function dQdxFirst(Q, x, mu, sigma) {
        x = Math.max(x, TINY);
        Q = Math.max(Q, TINY);
        mu = Math.max(TINY, Math.min(mu, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return mu * Q / x;
        }

        const rho = (sigma - 1.0) / sigma;
        return Math.pow(Q, 1.0 - rho) * Math.pow(mu, 1.0 / sigma) * Math.pow(x, rho - 1.0);
    }

    // Derivative wrt second input (weight 1-mu)
    function dQdySecond(Q, y, mu, sigma) {
        y = Math.max(y, TINY);
        Q = Math.max(Q, TINY);
        mu = Math.max(TINY, Math.min(mu, 1.0 - TINY));

        if (Math.abs(sigma - 1.0) < 1e-10) {
            return (1.0 - mu) * Q / y;
        }

        const rho = (sigma - 1.0) / sigma;
        return Math.pow(Q, 1.0 - rho) * Math.pow(1.0 - mu, 1.0 / sigma) * Math.pow(y, rho - 1.0);
    }

    // Bisection root finder
    function bisectRoot(func, lo, hi, maxIter = 80, tol = 1e-12) {
        let flo = func(lo);
        let fhi = func(hi);

        if (Math.abs(flo) < tol) return lo;
        if (Math.abs(fhi) < tol) return hi;

        if (flo * fhi > 0) {
            return Math.abs(flo) < Math.abs(fhi) ? lo : hi;
        }

        let a = lo, b = hi, fa = flo, fb = fhi;

        for (let i = 0; i < maxIter; i++) {
            const m = 0.5 * (a + b);
            const fm = func(m);

            if (Math.abs(fm) < tol || (b - a) < 1e-14) {
                return m;
            }

            if (fa * fm <= 0) {
                b = m;
                fb = fm;
            } else {
                a = m;
                fa = fm;
            }
        }

        return 0.5 * (a + b);
    }

    // Human split given wage ratio z = wc/wp
    // L_c/L_p = kappa * z^omega => ell_c = kappa*z^omega / (kappa*z^omega + 1)
    function humanSplit(L, z, kappa, omega) {
        z = Math.max(z, TINY);
        const x = kappa * Math.pow(z, omega);
        const ell = x / (x + 1.0);
        const Hc = ell * L;
        const Hp = (1.0 - ell) * L;
        return { Hc: Math.max(Hc, TINY), Hp: Math.max(Hp, TINY), ell_c: ell };
    }

    // Prices given mu and wage ratio z (which determines Hc, Hp via human split)
    function pricesGivenMuAndZ(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, z, params) {
        const { alpha, theta, eps, sig_c, sig_p, kappa, omega } = params;

        // Compute human split from wage ratio
        const split = humanSplit(L, z, kappa, omega);
        const Hc = split.Hc;
        const Hp = split.Hp;

        // Nests
        const L_cog = cesTaskAgg(Hc, AIc, mu_h_c, sig_c);
        const L_phys = cesTaskAgg(Hp, Rp, mu_h_p, sig_p);
        const L_eff = cesTaskAgg(L_cog, L_phys, theta, eps);

        // Infer A from Y = A K^alpha L_eff^(1-alpha)
        const A = Y / (Math.pow(K, alpha) * Math.pow(L_eff, 1.0 - alpha));
        const r = alpha * Y / K;
        const mp_Leff = (1.0 - alpha) * Y / L_eff;

        // Chain rule derivatives
        const dLeff_dLcog = dQdxFirst(L_eff, L_cog, theta, eps);
        const dLeff_dLphys = dQdySecond(L_eff, L_phys, theta, eps);

        const dLcog_dHc = dQdxFirst(L_cog, Hc, mu_h_c, sig_c);
        const dLcog_dAIc = dQdySecond(L_cog, AIc, mu_h_c, sig_c);

        const dLphys_dHp = dQdxFirst(L_phys, Hp, mu_h_p, sig_p);
        const dLphys_dRp = dQdySecond(L_phys, Rp, mu_h_p, sig_p);

        const wc = mp_Leff * dLeff_dLcog * dLcog_dHc;
        const qc = mp_Leff * dLeff_dLcog * dLcog_dAIc;
        const wp = mp_Leff * dLeff_dLphys * dLphys_dHp;
        const qr = mp_Leff * dLeff_dLphys * dLphys_dRp;

        const profit = Y - (r * K + wc * Hc + wp * Hp + qc * AIc + qr * Rp);

        return { A, r, wc, wp, qc, qr, Hc, Hp, ell_c: split.ell_c, profit };
    }

    // Inner solver: fixed-point iteration for z = wc/wp
    function solveZForMu(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, params, z0 = 1.0, damp = 0.6, maxIter = 200, tol = 1e-10) {
        let logz = Math.log(z0);

        for (let i = 0; i < maxIter; i++) {
            const z = Math.exp(logz);
            const out = pricesGivenMuAndZ(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, z, params);
            const z_hat = out.wc / out.wp;
            const logz_hat = Math.log(z_hat);

            if (Math.abs(logz_hat - logz) < tol) {
                out.z = Math.exp(logz_hat);
                return out;
            }

            logz = (1.0 - damp) * logz + damp * logz_hat;
        }

        // Return last result even if not fully converged
        const z = Math.exp(logz);
        const out = pricesGivenMuAndZ(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, z, params);
        out.z = z;
        out.z_converged = false;
        return out;
    }

    // Main solver for one year
    function solveMuOneYear(row, params) {
        const { Y, K, H_cog, AI_cog, R_phys, bar_auto_c, bar_auto_p } = row;

        const L = H_cog;  // Total human labor
        const AIc = AI_cog;
        const Rp = R_phys;

        // bar_auto is max automatable share => min human share = 1 - bar_auto
        const mu_h_c_min = Math.max(1e-9, Math.min(1.0 - 1e-9, 1.0 - Math.max(0, Math.min(bar_auto_c, 1.0 - 1e-12))));
        const mu_h_p_min = Math.max(1e-9, Math.min(1.0 - 1e-9, 1.0 - Math.max(0, Math.min(bar_auto_p, 1.0 - 1e-12))));

        // Start at frontier (automate as much as possible)
        let mu_h_c = mu_h_c_min;
        let mu_h_p = mu_h_p_min;

        // Solve for z at frontier
        let out = solveZForMu(Y, K, L, AIc, Rp, mu_h_c, mu_h_p, params, 1.0);

        const need_c = out.wc < out.qc;
        const need_p = out.wp < out.qr;

        // Coordinate bisection on mu's (each evaluation solves the inner z fixed-point)
        let mu_c_cur = mu_h_c;
        let mu_p_cur = mu_h_p;

        for (let iter = 0; iter < 30; iter++) {
            const prev_c = mu_c_cur;
            const prev_p = mu_p_cur;

            if (need_c) {
                const f = (mu) => {
                    const o = solveZForMu(Y, K, L, AIc, Rp, mu, mu_p_cur, params, 1.0);
                    return Math.log(o.wc / o.qc);
                };
                mu_c_cur = bisectRoot(f, mu_h_c_min, 1.0 - 1e-9);
            }

            if (need_p) {
                const g = (mu) => {
                    const o = solveZForMu(Y, K, L, AIc, Rp, mu_c_cur, mu, params, 1.0);
                    return Math.log(o.wp / o.qr);
                };
                mu_p_cur = bisectRoot(g, mu_h_p_min, 1.0 - 1e-9);
            }

            if (Math.max(Math.abs(mu_c_cur - prev_c), Math.abs(mu_p_cur - prev_p)) < 1e-10) {
                break;
            }
        }

        // Final solve with converged mu values
        const final = solveZForMu(Y, K, L, AIc, Rp, mu_c_cur, mu_p_cur, params, 1.0);

        return {
            ...final,
            mu_h_c: mu_c_cur,
            mu_h_p: mu_p_cur,
            mu_h_c_min: mu_h_c_min,
            mu_h_p_min: mu_h_p_min,
            H_cog_allocated: final.Hc,
            H_phys_allocated: final.Hp,
            regime_c: need_c ? "endogenous" : "frontier",
            regime_p: need_p ? "endogenous" : "frontier"
        };
    }

    // ========================================
    // CSV Parsing
    // ========================================

    function parseCell(x) {
        if (x === null || x === undefined || x === '') return NaN;

        const s = String(x).trim();
        if (s === '' || s.toLowerCase() === 'nan') return NaN;

        // Percentage
        if (s.endsWith('%')) {
            return parseFloat(s.slice(0, -1)) / 100.0;
        }

        // Remove $ and commas
        let s2 = s.replace(/\$/g, '').replace(/,/g, '').trim();

        // Match number with optional suffix
        const match = s2.match(/^([-+]?\d*\.?\d+)([KMBT])?$/i);
        if (match) {
            let num = parseFloat(match[1]);
            const suf = match[2];
            if (suf) {
                const mult = { 'K': 1e3, 'M': 1e6, 'B': 1e9, 'T': 1e12 };
                num *= mult[suf.toUpperCase()];
            }
            return num;
        }

        return parseFloat(s2);
    }

    function parseCSV(csvText) {
        const result = Papa.parse(csvText, {
            header: false,
            skipEmptyLines: false
        });

        const rows = result.data;
        if (rows.length === 0) {
            throw new Error("Empty CSV file");
        }

        // First row should be headers with years
        const headerRow = rows[0];
        const yearCols = [];
        const years = [];

        for (let i = 0; i < headerRow.length; i++) {
            const val = String(headerRow[i]).trim();
            if (/^\d{4}$/.test(val)) {
                yearCols.push(i);
                years.push(parseInt(val));
            }
        }

        if (years.length === 0) {
            throw new Error("No year columns found in the header row");
        }

        // Build label to series map
        const labelToSeries = {};
        for (let r = 1; r < rows.length; r++) {
            const row = rows[r];
            if (!row || !row[0]) continue;

            const label = String(row[0]).trim();
            if (!label) continue;

            const series = yearCols.map(i => parseCell(row[i]));
            labelToSeries[label] = series;
        }

        // Column name mappings (new template names -> internal names)
        // Support both old format and new simplified format
        const columnMappings = {
            // Human labor
            "Human Labor Force": "H",
            "US Human Labor Force": "H",
            // AI cognitive
            "AI Cognitive": "AI_cog",
            "US AI cognitive": "AI_cog",
            // Robotic physical
            "Robotic Physical": "R_phys",
            "US RObotic physical": "R_phys",
            // Output
            "Output": "Y",
            "US Economy": "Y",
            // Capital
            "Capital": "K",
            "US 'Normal' Capital": "K",
            // Cognitive automation frontier
            "Cognitive Automation Frontier": "bar_auto_c",
            "% of cognitive jobs that can be automated": "bar_auto_c",
            // Physical automation frontier
            "Physical Automation Frontier": "bar_auto_p",
            "% of physical jobs that can be automated": "bar_auto_p"
        };

        // Map labels to internal names
        const mappedSeries = {};
        for (const [label, series] of Object.entries(labelToSeries)) {
            if (columnMappings[label]) {
                mappedSeries[columnMappings[label]] = series;
            }
        }

        // Check required fields
        const requiredFields = ["H", "AI_cog", "R_phys", "Y", "K", "bar_auto_c", "bar_auto_p"];
        const missingFields = requiredFields.filter(f => !mappedSeries[f]);

        if (missingFields.length > 0) {
            throw new Error(`Missing required rows. Please ensure your CSV has: Human Labor Force, AI Cognitive, Robotic Physical, Output, Capital, Cognitive Automation Frontier, Physical Automation Frontier`);
        }

        // Build data array
        const data = [];
        for (let i = 0; i < years.length; i++) {
            data.push({
                year: years[i],
                Y: mappedSeries["Y"][i],
                K: mappedSeries["K"][i],
                H_cog: mappedSeries["H"][i],
                H_phys: mappedSeries["H"][i],
                AI_cog: mappedSeries["AI_cog"][i],
                R_phys: mappedSeries["R_phys"][i],
                bar_auto_c: mappedSeries["bar_auto_c"][i],
                bar_auto_p: mappedSeries["bar_auto_p"][i]
            });
        }

        return data;
    }

    // ========================================
    // Charting
    // ========================================

    let wagesChart = null;
    let muChart = null;

    function createCharts(results) {
        const years = results.map(r => r.year);
        const wc = results.map(r => r.wc);
        const wp = results.map(r => r.wp);
        const qc = results.map(r => r.qc);
        const qr = results.map(r => r.qr);
        const mu_h_c = results.map(r => r.mu_h_c);
        const mu_h_p = results.map(r => r.mu_h_p);
        const mu_h_c_min = results.map(r => r.mu_h_c_min);
        const mu_h_p_min = results.map(r => r.mu_h_p_min);

        // Destroy existing charts
        if (wagesChart) wagesChart.destroy();
        if (muChart) muChart.destroy();

        // Wages and Machine Prices chart
        const wagesCtx = document.getElementById('wagesChart').getContext('2d');
        wagesChart = new Chart(wagesCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Human cognitive (wc)',
                        data: wc,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'AI cognitive (qc)',
                        data: qc,
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Human physical (wp)',
                        data: wp,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Robot physical (qp)',
                        data: qr,
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Wages and machine prices over time'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Price / wage'
                        },
                        beginAtZero: true
                    }
                }
            }
        });

        // Mu terms chart
        const muCtx = document.getElementById('muChart').getContext('2d');
        muChart = new Chart(muCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Cognitive: automated (eq)',
                        data: mu_h_c.map(m => 1 - m),
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Cognitive: automatable (frontier)',
                        data: mu_h_c_min.map(m => 1 - m),
                        borderColor: 'rgb(31, 119, 180)',
                        backgroundColor: 'rgb(31, 119, 180)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Physical: automated (eq)',
                        data: mu_h_p.map(m => 1 - m),
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Physical: automatable (frontier)',
                        data: mu_h_p_min.map(m => 1 - m),
                        borderColor: 'rgb(255, 127, 14)',
                        backgroundColor: 'rgb(255, 127, 14)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Automatable vs automated task shares'
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Task share'
                        },
                        min: 0,
                        max: 1
                    }
                }
            }
        });
    }

    function createResultsTable(results) {
        const container = document.getElementById('tableContainer');

        let html = '<table><thead><tr>';
        html += '<th>Year</th><th>H_c</th><th>H_p</th><th>mu_h_c</th><th>mu_h_p</th><th>w_c</th><th>q_c</th><th>w_p</th><th>q_p</th><th>Regime C</th><th>Regime P</th>';
        html += '</tr></thead><tbody>';

        for (const r of results) {
            html += '<tr>';
            html += `<td>${r.year}</td>`;
            html += `<td>${r.H_cog_allocated.toExponential(2)}</td>`;
            html += `<td>${r.H_phys_allocated.toExponential(2)}</td>`;
            html += `<td>${r.mu_h_c.toFixed(4)}</td>`;
            html += `<td>${r.mu_h_p.toFixed(4)}</td>`;
            html += `<td>${r.wc.toExponential(2)}</td>`;
            html += `<td>${r.qc.toExponential(2)}</td>`;
            html += `<td>${r.wp.toExponential(2)}</td>`;
            html += `<td>${r.qr.toExponential(2)}</td>`;
            html += `<td>${r.regime_c}</td>`;
            html += `<td>${r.regime_p}</td>`;
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
        document.getElementById('resultsTable').classList.remove('hidden');
    }

    // ========================================
    // Main App Logic
    // ========================================

    let loadedData = null;

    function showStatus(message, type) {
        const statusEl = document.getElementById('status');
        statusEl.textContent = message;
        statusEl.className = 'status ' + type;
        statusEl.classList.remove('hidden');
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const csvText = event.target.result;
                loadedData = parseCSV(csvText);
                showStatus(`Loaded ${loadedData.length} years of data (${loadedData[0].year} - ${loadedData[loadedData.length-1].year})`, 'success');
                document.getElementById('runModel').disabled = false;
            } catch (err) {
                showStatus('Error parsing file: ' + err.message, 'error');
                loadedData = null;
                document.getElementById('runModel').disabled = true;
            }
        };
        reader.readAsText(file);
    });

    document.getElementById('runModel').addEventListener('click', function() {
        if (!loadedData) {
            showStatus('Please upload a CSV file first', 'error');
            return;
        }

        try {
            showStatus('Running model...', 'info');

            const params = getParams();
            const results = loadedData.map(row => ({
                year: row.year,
                ...row,
                ...solveMuOneYear(row, params)
            }));

            createCharts(results);
            createResultsTable(results);

            showStatus('Model completed successfully!', 'success');
        } catch (err) {
            showStatus('Error running model: ' + err.message, 'error');
            console.error(err);
        }
    });

    // Template download
    document.getElementById('downloadTemplate').addEventListener('click', function() {
        const templateCSV = `,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040
Human Labor Force,168.6M,169.0M,169.3M,169.6M,169.8M,167.3M,167.3M,157.5M,141.6M,141.6M,113.7M,85.3M,56.2M,41.7M,36.0M,33.3M
AI Cognitive,0.2M,0.9M,3.9M,16.4M,51.8M,191.7M,841.6M,6.0B,50.1B,485.7B,5.5T,11.3T,22.5T,44.5T,87.7T,172.4T
Robotic Physical,0.6,5.5,49.4,0.4K,4.0K,48.0K,576.0K,8.6M,129.6M,1.9B,17.5B,96.2B,529.3B,2.9T,16.0T,88.1T
Output,29.7T,30T,31T,32T,32T,33T,35T,38T,44T,61T,116T,198T,361T,685T,1329T,2618T
Capital,110T,111T,111T,112T,113T,113T,114T,115T,117T,120T,126T,143T,176T,239T,364T,612T
Cognitive Automation Frontier,2%,3%,5%,17%,38%,52%,65%,78%,92%,100%,100%,100%,100%,100%,100%,100%
Physical Automation Frontier,2%,2%,2%,2%,5%,17%,38%,52%,65%,78%,92%,100%,100%,100%,100%,100%`;

        const blob = new Blob([templateCSV], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'scenario_template.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });
    </script>
</body>
</html>
